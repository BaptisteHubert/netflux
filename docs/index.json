[
  {
    "__docId__": 0,
    "kind": "file",
    "name": "src/BotServerFacade.js",
    "content": "import { BotServer } from './BotServer';\nlet botServer;\n/**\n * Bot server may be a member of severals groups. Each group is isolated.\n * He can be invited by a group member via {@link WebGroup#invite} method.\n * @example\n * // In NodeJS:\n * // Create a bot server with full mesh topology, without autorejoin feature\n * // and with specified Signaling and ICE servers for WebRTC.\n * // Bot server is listening on 'ws://BOT_HOST:BOT_PORT'.\n *\n * const http = require('http')\n * const server = http.createServer()\n * const bot = new WebGroupBotServer({\n *   server,\n *   webGroupOptions: {\n *     signalingServer: 'wss://mysignaling.com',\n *     rtcConfiguration: {\n *       iceServers: [\n *         {\n *           urls: 'stun.l.google.com:19302'\n *         },\n *         {\n *           urls: ['turn:myturn.com?transport=udp', 'turn:myturn?transport=tcp'],\n *           username: 'user',\n *           password: 'password'\n *         }\n *       ]\n *     }\n *   }\n * })\n *\n * bot.onWebGroup = (wg) => {\n *   // YOUR CODE\n * }\n *\n * bot.onError = (err) => {\n *   // YOUR CODE\n * }\n *\n * server.listen(BOT_PORT, BOT_HOST)\n */\nexport class WebGroupBotServer {\n    /**\n     * @param {WebGroupBotServerOptions} options\n     * @param {NodeJSHttpServer|NodeJSHttpsServer} options.server NodeJS http(s) server.\n     * @param {string} [options.url] Bot server URL.\n     * @param {boolean} [options.perMessageDeflate=false] Enable/disable permessage-deflate.\n     * @param {WebGroupOptions} options.webGroupOptions Options for each {@link WebGroup} the bot is member of.\n     * @param {Topology} [options.webGroupOptions.topology=Topology.FULL_MESH]\n     * @param {string} [options.webGroupOptions.signalingServer='wss://signaling.netflux.coedit.re']\n     * @param {RTCConfiguration} [options.webGroupOptions.rtcConfiguration={iceServers: [{urls: 'stun:stun3.l.google.com:19302'}]}]\n     * @param {boolean} [options.webGroupOptions.autoRejoin=false]\n     */\n    constructor(options) {\n        botServer = new BotServer(options);\n        /**\n         * Read-only NodeJS http server instance.\n         * @type {NodeJSHttpServer|NodeJSHttpsServer}\n         */\n        this.server = undefined;\n        Reflect.defineProperty(this, 'server', {\n            configurable: false,\n            enumerable: true,\n            get: () => botServer.server,\n        });\n        /**\n         * Read-only property of WebSocket server: permessage-deflate.\n         * @type {NodeJSHttpServer|NodeJSHttpsServer}\n         */\n        this.perMessageDeflate = undefined;\n        Reflect.defineProperty(this, 'perMessageDeflate', {\n            configurable: false,\n            enumerable: true,\n            get: () => botServer.perMessageDeflate,\n        });\n        /**\n         * Read-only set of web groups the bot is member of.\n         * @type {Set<WebGroup>}\n         */\n        this.webGroups = undefined;\n        Reflect.defineProperty(this, 'webGroups', {\n            configurable: false,\n            enumerable: true,\n            get: () => botServer.webGroups,\n        });\n        /**\n         * Bot server url. Used to invite the bot in a web group via {@link WebGroup#invite} method.\n         * @type {string}\n         */\n        this.url = undefined;\n        Reflect.defineProperty(this, 'url', {\n            configurable: false,\n            enumerable: true,\n            get: () => botServer.url,\n        });\n        /**\n         * This handler is called when the bot has been invited into a group by one of its members.\n         * @type  {function(wg: WebGroup)} handler\n         */\n        this.onWebGroup = undefined;\n        Reflect.defineProperty(this, 'onWebGroup', {\n            configurable: true,\n            enumerable: true,\n            get: () => (botServer.onWebGroup.name === 'none' ? undefined : botServer.onWebGroup),\n            set: (handler) => {\n                if (typeof handler !== 'function') {\n                    botServer.onWebGroup = function none() { };\n                }\n                else {\n                    botServer.onWebGroup = handler;\n                }\n            },\n        });\n        /**\n         * This handler is called when an error occurs on WebSocket server.\n         * @type  {function(err: Error)}\n         */\n        this.onError = undefined;\n        Reflect.defineProperty(this, 'onError', {\n            configurable: true,\n            enumerable: true,\n            get: () => (botServer.onError.name === 'none' ? undefined : botServer.onError),\n            set: (handler) => {\n                if (typeof handler !== 'function') {\n                    botServer.onError = function none() { };\n                }\n                else {\n                    botServer.onError = handler;\n                }\n            },\n        });\n    }\n}\n",
    "static": true,
    "longname": "/home/philippe/workspace/netflux/docs/jsFromTs/src/BotServerFacade.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 1,
    "kind": "class",
    "name": "WebGroupBotServer",
    "memberof": "src/BotServerFacade.js",
    "static": true,
    "longname": "src/BotServerFacade.js~WebGroupBotServer",
    "access": "public",
    "export": true,
    "importPath": "netflux/src/BotServerFacade.js",
    "importStyle": "{WebGroupBotServer}",
    "description": "Bot server may be a member of severals groups. Each group is isolated.\nHe can be invited by a group member via {@link WebGroup#invite} method.",
    "examples": [
      "// In NodeJS:\n// Create a bot server with full mesh topology, without autorejoin feature\n// and with specified Signaling and ICE servers for WebRTC.\n// Bot server is listening on 'ws://BOT_HOST:BOT_PORT'.\n\nconst http = require('http')\nconst server = http.createServer()\nconst bot = new WebGroupBotServer({\n  server,\n  webGroupOptions: {\n    signalingServer: 'wss://mysignaling.com',\n    rtcConfiguration: {\n      iceServers: [\n        {\n          urls: 'stun.l.google.com:19302'\n        },\n        {\n          urls: ['turn:myturn.com?transport=udp', 'turn:myturn?transport=tcp'],\n          username: 'user',\n          password: 'password'\n        }\n      ]\n    }\n  }\n})\n\nbot.onWebGroup = (wg) => {\n  // YOUR CODE\n}\n\nbot.onError = (err) => {\n  // YOUR CODE\n}\n\nserver.listen(BOT_PORT, BOT_HOST)"
    ],
    "lineNumber": 43,
    "interface": false
  },
  {
    "__docId__": 2,
    "kind": "constructor",
    "name": "constructor",
    "memberof": "src/BotServerFacade.js~WebGroupBotServer",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/BotServerFacade.js~WebGroupBotServer#constructor",
    "access": "public",
    "description": "",
    "lineNumber": 55,
    "params": [
      {
        "nullable": null,
        "types": [
          "WebGroupBotServerOptions"
        ],
        "spread": false,
        "optional": false,
        "name": "options",
        "description": ""
      },
      {
        "nullable": null,
        "types": [
          "NodeJSHttpServer",
          "NodeJSHttpsServer"
        ],
        "spread": false,
        "optional": false,
        "name": "options.server",
        "description": "NodeJS http(s) server."
      },
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": true,
        "name": "options.url",
        "description": "Bot server URL."
      },
      {
        "nullable": null,
        "types": [
          "boolean"
        ],
        "spread": false,
        "optional": true,
        "defaultValue": "false",
        "defaultRaw": false,
        "name": "options.perMessageDeflate",
        "description": "Enable/disable permessage-deflate."
      },
      {
        "nullable": null,
        "types": [
          "WebGroupOptions"
        ],
        "spread": false,
        "optional": false,
        "name": "options.webGroupOptions",
        "description": "Options for each {@link WebGroup} the bot is member of."
      },
      {
        "nullable": null,
        "types": [
          "Topology"
        ],
        "spread": false,
        "optional": true,
        "defaultValue": "Topology.FULL_MESH",
        "defaultRaw": "Topology.FULL_MESH",
        "name": "options.webGroupOptions.topology",
        "description": ""
      },
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": true,
        "defaultValue": "'wss://signaling.netflux.coedit.re'",
        "defaultRaw": "'wss://signaling.netflux.coedit.re'",
        "name": "options.webGroupOptions.signalingServer",
        "description": ""
      },
      {
        "nullable": null,
        "types": [
          "RTCConfiguration"
        ],
        "spread": false,
        "optional": true,
        "defaultValue": "{iceServers: [{urls: 'stun:stun3.l.google.com:19302'}]}",
        "defaultRaw": "{iceServers: [{urls: 'stun:stun3.l.google.com:19302'}]}",
        "name": "options.webGroupOptions.rtcConfiguration",
        "description": ""
      },
      {
        "nullable": null,
        "types": [
          "boolean"
        ],
        "spread": false,
        "optional": true,
        "defaultValue": "false",
        "defaultRaw": false,
        "name": "options.webGroupOptions.autoRejoin",
        "description": ""
      }
    ]
  },
  {
    "__docId__": 3,
    "kind": "member",
    "name": "server",
    "memberof": "src/BotServerFacade.js~WebGroupBotServer",
    "static": false,
    "longname": "src/BotServerFacade.js~WebGroupBotServer#server",
    "access": "public",
    "description": "Read-only NodeJS http server instance.",
    "lineNumber": 61,
    "type": {
      "nullable": null,
      "types": [
        "NodeJSHttpServer",
        "NodeJSHttpsServer"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 4,
    "kind": "member",
    "name": "perMessageDeflate",
    "memberof": "src/BotServerFacade.js~WebGroupBotServer",
    "static": false,
    "longname": "src/BotServerFacade.js~WebGroupBotServer#perMessageDeflate",
    "access": "public",
    "description": "Read-only property of WebSocket server: permessage-deflate.",
    "lineNumber": 71,
    "type": {
      "nullable": null,
      "types": [
        "NodeJSHttpServer",
        "NodeJSHttpsServer"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 5,
    "kind": "member",
    "name": "webGroups",
    "memberof": "src/BotServerFacade.js~WebGroupBotServer",
    "static": false,
    "longname": "src/BotServerFacade.js~WebGroupBotServer#webGroups",
    "access": "public",
    "description": "Read-only set of web groups the bot is member of.",
    "lineNumber": 81,
    "type": {
      "nullable": null,
      "types": [
        "Set<WebGroup>"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 6,
    "kind": "member",
    "name": "url",
    "memberof": "src/BotServerFacade.js~WebGroupBotServer",
    "static": false,
    "longname": "src/BotServerFacade.js~WebGroupBotServer#url",
    "access": "public",
    "description": "Bot server url. Used to invite the bot in a web group via {@link WebGroup#invite} method.",
    "lineNumber": 91,
    "type": {
      "nullable": null,
      "types": [
        "string"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 7,
    "kind": "member",
    "name": "onWebGroup",
    "memberof": "src/BotServerFacade.js~WebGroupBotServer",
    "static": false,
    "longname": "src/BotServerFacade.js~WebGroupBotServer#onWebGroup",
    "access": "public",
    "description": "This handler is called when the bot has been invited into a group by one of its members.",
    "lineNumber": 101,
    "type": {
      "nullable": null,
      "types": [
        "function(wg: WebGroup)"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 8,
    "kind": "member",
    "name": "onError",
    "memberof": "src/BotServerFacade.js~WebGroupBotServer",
    "static": false,
    "longname": "src/BotServerFacade.js~WebGroupBotServer#onError",
    "access": "public",
    "description": "This handler is called when an error occurs on WebSocket server.",
    "lineNumber": 119,
    "type": {
      "nullable": null,
      "types": [
        "function(err: Error)"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 9,
    "kind": "file",
    "name": "src/WebChannelFacade.js",
    "content": "import { WebChannel } from './WebChannel';\n/**\n * Is a helper type representing types that can be sent/received over a web group.\n * @typedef {string|Uint8Array} DataType\n */\n/**\n * @ignore\n */\nexport const wcs = new WeakMap();\n/**\n * This class is an API starting point. It represents a peer to peer network,\n * simply called a group. Each group member can send/receive broadcast\n * as well as personal messages, invite other persons or bots (see {@link WebGroupBotServer}).\n * @example\n * // Create a WebGroup with full mesh topology, autorejoin feature and\n * // specified Signaling and ICE servers for WebRTC.\n *\n * const wg = new WebGroup({\n *   signalingServer: 'wss://mysignaling.com',\n *   rtcConfiguration: {\n *     iceServers: [\n *       {\n *         urls: 'stun.l.google.com:19302'\n *       },\n *       {\n *         urls: ['turn:myturn.com?transport=udp', 'turn:myturn?transport=tcp'],\n *         username: 'user',\n *         password: 'password'\n *       }\n *     ]\n *   }\n * })\n *\n * wg.onMemberJoin = (id) => {\n *   // YOUR CODE...\n * }\n * wg.onMemberLeave = (id) => {\n *   // YOUR CODE...\n * }\n * wg.onMessage = (id, data) => {\n *   // YOUR CODE...\n * }\n * wg.onStateChange = (state) => {\n *   // YOUR CODE...\n * }\n * wg.onSignalingStateChange = (state) => {\n *   // YOUR CODE...\n * }\n */\nexport class WebGroup {\n    /**\n     * @param {WebGroupOptions} [options]\n     * @param {Topology} [options.topology=Topology.FULL_MESH]\n     * @param {string} [options.signalingServer='wss://signaling.netflux.coedit.re']\n     * @param {RTCConfiguration} [options.rtcConfiguration={iceServers: [{urls: 'stun:stun3.l.google.com:19302'}]}]\n     * @param {boolean} [options.autoRejoin=true]\n     */\n    constructor(options = {}) {\n        const wc = new WebChannel(options);\n        wcs.set(this, wc);\n        /**\n         * The read-only {@link WebGroup} identifier. The same value for all members.\n         * @type {number}\n         */\n        this.id = undefined;\n        Reflect.defineProperty(this, 'id', { configurable: false, enumerable: true, get: () => wc.id });\n        /**\n         * The read-only your unique member identifier in the group.\n         * @type {number}\n         */\n        this.myId = undefined;\n        Reflect.defineProperty(this, 'myId', {\n            configurable: false,\n            enumerable: true,\n            get: () => wc.myId,\n        });\n        /**\n         * The read-only group session identifier. Equals to an empty string before calling {@link WebGroup#join}.\n         * Different to {@link WebGroup#id}. This key is known and used by Signaling server\n         * in order to join new members, on the other hand Signaling does not know {@link WebGroup#id}.\n         * @type {string}\n         */\n        this.key = undefined;\n        Reflect.defineProperty(this, 'key', {\n            configurable: false,\n            enumerable: true,\n            get: () => wc.key,\n        });\n        /**\n         * The read-only array of all members including yourself (i.e. {@link WebGroup#myId})\n         * @type {number[]}\n         */\n        this.members = undefined;\n        Reflect.defineProperty(this, 'members', {\n            configurable: false,\n            enumerable: true,\n            get: () => wc.members,\n        });\n        /**\n         * The read-only property which is an enum of type {@link Topology}\n         * indicating the topology used for this {@link WebGroup} instance.\n         * @type {Topology}\n         */\n        this.topology = undefined;\n        Reflect.defineProperty(this, 'topology', {\n            configurable: false,\n            enumerable: true,\n            get: () => wc.topology,\n        });\n        /**\n         * The read-only state of the {@link WebGroup} connection.\n         * @type {WebGroupState}\n         */\n        this.state = undefined;\n        Reflect.defineProperty(this, 'state', {\n            configurable: false,\n            enumerable: true,\n            get: () => wc.state,\n        });\n        /**\n         * The read-only state of the signaling server.\n         * @type {SignalingState}\n         */\n        this.signalingState = undefined;\n        Reflect.defineProperty(this, 'signalingState', {\n            configurable: false,\n            enumerable: true,\n            get: () => wc.signaling.state,\n        });\n        /**\n         * The read-only signaling server URL.\n         * @type {string}\n         */\n        this.signalingServer = undefined;\n        Reflect.defineProperty(this, 'signalingServer', {\n            configurable: false,\n            enumerable: true,\n            get: () => wc.signaling.url,\n        });\n        /**\n         * Enable/Desable the auto rejoin feature.\n         * @type {boolean}\n         */\n        this.autoRejoin = undefined;\n        Reflect.defineProperty(this, 'autoRejoin', {\n            configurable: false,\n            enumerable: true,\n            get: () => wc.autoRejoin,\n            set: (value) => (wc.autoRejoin = value),\n        });\n        /**\n         * This handler is called when a message has been received from the group.\n         * `id` is an identifier of the member who sent this message.\n         * and false if sent via {@link WebGroup#sendTo}.\n         * @type {function(id: number, data: DataType)}\n         */\n        this.onMessage = undefined;\n        Reflect.defineProperty(this, 'onMessage', {\n            configurable: true,\n            enumerable: true,\n            get: () => (wc.onMessage.name === 'none' ? undefined : wc.onMessage),\n            set: (handler) => {\n                if (typeof handler !== 'function') {\n                    wc.onMessage = function none() { };\n                }\n                else {\n                    wc.onMessage = handler;\n                }\n            },\n        });\n        /**\n         * This handler is called when a new member with `id` as identifier has joined the group.\n         * @type {function(id: number)}\n         */\n        this.onMemberJoin = undefined;\n        Reflect.defineProperty(this, 'onMemberJoin', {\n            configurable: true,\n            enumerable: true,\n            get: () => (wc.onMemberJoin.name === 'none' ? undefined : wc.onMemberJoin),\n            set: (handler) => {\n                if (typeof handler !== 'function') {\n                    wc.onMemberJoin = function none() { };\n                }\n                else {\n                    wc.onMemberJoin = handler;\n                }\n            },\n        });\n        /**\n         * This handler is called when a member with `id` as identifier hes left the group.\n         * @type {function(id: number)}\n         */\n        this.onMemberLeave = undefined;\n        Reflect.defineProperty(this, 'onMemberLeave', {\n            configurable: true,\n            enumerable: true,\n            get: () => (wc.onMemberLeave.name === 'none' ? undefined : wc.onMemberLeave),\n            set: (handler) => {\n                if (typeof handler !== 'function') {\n                    wc.onMemberLeave = function none() { };\n                }\n                else {\n                    wc.onMemberLeave = handler;\n                }\n            },\n        });\n        /**\n         * This handler is called when the group state has changed.\n         * @type {function(state: WebGroupState)}\n         */\n        this.onStateChange = undefined;\n        Reflect.defineProperty(this, 'onStateChange', {\n            configurable: true,\n            enumerable: true,\n            get: () => (wc.onStateChange.name === 'none' ? undefined : wc.onStateChange),\n            set: (handler) => {\n                if (typeof handler !== 'function') {\n                    wc.onStateChange = function none() { };\n                }\n                else {\n                    wc.onStateChange = handler;\n                }\n            },\n        });\n        /**\n         * This handler is called when the signaling state has changed.\n         * @type {function(state: SignalingState)}\n         */\n        this.onSignalingStateChange = undefined;\n        Reflect.defineProperty(this, 'onSignalingStateChange', {\n            configurable: true,\n            enumerable: true,\n            get: () => wc.onSignalingStateChange.name === 'none' ? undefined : wc.onSignalingStateChange,\n            set: (handler) => {\n                if (typeof handler !== 'function') {\n                    wc.onSignalingStateChange = function none() { };\n                }\n                else {\n                    wc.onSignalingStateChange = handler;\n                }\n            },\n        });\n    }\n    /**\n     * Join the group identified by a key provided by one of the group member.\n     * If the current {@link WebGroup#state} value is not {@link WebGroupState#LEFT} or\n     * {@link WebGroup#signalingState} value is not {@link SignalingState.CLOSED},\n     * then do nothing.\n     * @param {string} [key] Will be generated if not provided\n     */\n    join(key) {\n        const wc = wcs.get(this);\n        if (wc) {\n            return wc.join(key);\n        }\n        throw new Error('WebChannel is undefined');\n    }\n    /**\n     * Invite a bot server to join this group.\n     * @param {string} url - Bot server URL (See {@link WebGroupBotServerOptions})\n     */\n    invite(url) {\n        const wc = wcs.get(this);\n        if (wc) {\n            return wc.invite(url);\n        }\n        throw new Error('WebChannel is undefined');\n    }\n    /**\n     * Leave the group which means close channels with all members and connection\n     * with the Signaling server.\n     */\n    leave() {\n        const wc = wcs.get(this);\n        if (wc) {\n            return wc.leave();\n        }\n        throw new Error('WebChannel is undefined');\n    }\n    /**\n     * Broadcast a message to the group.\n     * @param {DataType} data\n     */\n    send(data) {\n        const wc = wcs.get(this);\n        if (wc) {\n            return wc.send(data);\n        }\n        throw new Error('WebChannel is undefined');\n    }\n    /**\n     * Send a message to a particular group member.\n     * @param {number}    id Member identifier\n     * @param {DataType}  data Message\n     */\n    sendTo(id, data) {\n        const wc = wcs.get(this);\n        if (wc) {\n            return wc.sendTo(id, data);\n        }\n        throw new Error('WebChannel is undefined');\n    }\n}\n",
    "static": true,
    "longname": "/home/philippe/workspace/netflux/docs/jsFromTs/src/WebChannelFacade.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 10,
    "kind": "typedef",
    "name": "DataType",
    "memberof": "src/WebChannelFacade.js",
    "static": true,
    "longname": "src/WebChannelFacade.js~DataType",
    "access": "public",
    "description": "Is a helper type representing types that can be sent/received over a web group.",
    "type": {
      "types": [
        "string",
        "Uint8Array"
      ],
      "optional": false,
      "name": "DataType"
    }
  },
  {
    "__docId__": 11,
    "kind": "variable",
    "name": "wcs",
    "memberof": "src/WebChannelFacade.js",
    "static": true,
    "longname": "src/WebChannelFacade.js~wcs",
    "access": "public",
    "export": true,
    "importPath": "netflux/src/WebChannelFacade.js",
    "importStyle": "{wcs}",
    "description": "",
    "lineNumber": 9,
    "ignore": true
  },
  {
    "__docId__": 12,
    "kind": "class",
    "name": "WebGroup",
    "memberof": "src/WebChannelFacade.js",
    "static": true,
    "longname": "src/WebChannelFacade.js~WebGroup",
    "access": "public",
    "export": true,
    "importPath": "netflux/src/WebChannelFacade.js",
    "importStyle": "{WebGroup}",
    "description": "This class is an API starting point. It represents a peer to peer network,\nsimply called a group. Each group member can send/receive broadcast\nas well as personal messages, invite other persons or bots (see {@link WebGroupBotServer}).",
    "examples": [
      "// Create a WebGroup with full mesh topology, autorejoin feature and\n// specified Signaling and ICE servers for WebRTC.\n\nconst wg = new WebGroup({\n  signalingServer: 'wss://mysignaling.com',\n  rtcConfiguration: {\n    iceServers: [\n      {\n        urls: 'stun.l.google.com:19302'\n      },\n      {\n        urls: ['turn:myturn.com?transport=udp', 'turn:myturn?transport=tcp'],\n        username: 'user',\n        password: 'password'\n      }\n    ]\n  }\n})\n\nwg.onMemberJoin = (id) => {\n  // YOUR CODE...\n}\nwg.onMemberLeave = (id) => {\n  // YOUR CODE...\n}\nwg.onMessage = (id, data) => {\n  // YOUR CODE...\n}\nwg.onStateChange = (state) => {\n  // YOUR CODE...\n}\nwg.onSignalingStateChange = (state) => {\n  // YOUR CODE...\n}"
    ],
    "lineNumber": 50,
    "interface": false
  },
  {
    "__docId__": 13,
    "kind": "constructor",
    "name": "constructor",
    "memberof": "src/WebChannelFacade.js~WebGroup",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/WebChannelFacade.js~WebGroup#constructor",
    "access": "public",
    "description": "",
    "lineNumber": 58,
    "params": [
      {
        "nullable": null,
        "types": [
          "WebGroupOptions"
        ],
        "spread": false,
        "optional": true,
        "name": "options",
        "description": ""
      },
      {
        "nullable": null,
        "types": [
          "Topology"
        ],
        "spread": false,
        "optional": true,
        "defaultValue": "Topology.FULL_MESH",
        "defaultRaw": "Topology.FULL_MESH",
        "name": "options.topology",
        "description": ""
      },
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": true,
        "defaultValue": "'wss://signaling.netflux.coedit.re'",
        "defaultRaw": "'wss://signaling.netflux.coedit.re'",
        "name": "options.signalingServer",
        "description": ""
      },
      {
        "nullable": null,
        "types": [
          "RTCConfiguration"
        ],
        "spread": false,
        "optional": true,
        "defaultValue": "{iceServers: [{urls: 'stun:stun3.l.google.com:19302'}]}",
        "defaultRaw": "{iceServers: [{urls: 'stun:stun3.l.google.com:19302'}]}",
        "name": "options.rtcConfiguration",
        "description": ""
      },
      {
        "nullable": null,
        "types": [
          "boolean"
        ],
        "spread": false,
        "optional": true,
        "defaultValue": "true",
        "defaultRaw": true,
        "name": "options.autoRejoin",
        "description": ""
      }
    ]
  },
  {
    "__docId__": 14,
    "kind": "member",
    "name": "id",
    "memberof": "src/WebChannelFacade.js~WebGroup",
    "static": false,
    "longname": "src/WebChannelFacade.js~WebGroup#id",
    "access": "public",
    "description": "The read-only {@link WebGroup} identifier. The same value for all members.",
    "lineNumber": 65,
    "type": {
      "nullable": null,
      "types": [
        "number"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 15,
    "kind": "member",
    "name": "myId",
    "memberof": "src/WebChannelFacade.js~WebGroup",
    "static": false,
    "longname": "src/WebChannelFacade.js~WebGroup#myId",
    "access": "public",
    "description": "The read-only your unique member identifier in the group.",
    "lineNumber": 71,
    "type": {
      "nullable": null,
      "types": [
        "number"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 16,
    "kind": "member",
    "name": "key",
    "memberof": "src/WebChannelFacade.js~WebGroup",
    "static": false,
    "longname": "src/WebChannelFacade.js~WebGroup#key",
    "access": "public",
    "description": "The read-only group session identifier. Equals to an empty string before calling {@link WebGroup#join}.\nDifferent to {@link WebGroup#id}. This key is known and used by Signaling server\nin order to join new members, on the other hand Signaling does not know {@link WebGroup#id}.",
    "lineNumber": 83,
    "type": {
      "nullable": null,
      "types": [
        "string"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 17,
    "kind": "member",
    "name": "members",
    "memberof": "src/WebChannelFacade.js~WebGroup",
    "static": false,
    "longname": "src/WebChannelFacade.js~WebGroup#members",
    "access": "public",
    "description": "The read-only array of all members including yourself (i.e. {@link WebGroup#myId})",
    "lineNumber": 93,
    "type": {
      "nullable": null,
      "types": [
        "number[]"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 18,
    "kind": "member",
    "name": "topology",
    "memberof": "src/WebChannelFacade.js~WebGroup",
    "static": false,
    "longname": "src/WebChannelFacade.js~WebGroup#topology",
    "access": "public",
    "description": "The read-only property which is an enum of type {@link Topology}\nindicating the topology used for this {@link WebGroup} instance.",
    "lineNumber": 104,
    "type": {
      "nullable": null,
      "types": [
        "Topology"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 19,
    "kind": "member",
    "name": "state",
    "memberof": "src/WebChannelFacade.js~WebGroup",
    "static": false,
    "longname": "src/WebChannelFacade.js~WebGroup#state",
    "access": "public",
    "description": "The read-only state of the {@link WebGroup} connection.",
    "lineNumber": 114,
    "type": {
      "nullable": null,
      "types": [
        "WebGroupState"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 20,
    "kind": "member",
    "name": "signalingState",
    "memberof": "src/WebChannelFacade.js~WebGroup",
    "static": false,
    "longname": "src/WebChannelFacade.js~WebGroup#signalingState",
    "access": "public",
    "description": "The read-only state of the signaling server.",
    "lineNumber": 124,
    "type": {
      "nullable": null,
      "types": [
        "SignalingState"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 21,
    "kind": "member",
    "name": "signalingServer",
    "memberof": "src/WebChannelFacade.js~WebGroup",
    "static": false,
    "longname": "src/WebChannelFacade.js~WebGroup#signalingServer",
    "access": "public",
    "description": "The read-only signaling server URL.",
    "lineNumber": 134,
    "type": {
      "nullable": null,
      "types": [
        "string"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 22,
    "kind": "member",
    "name": "autoRejoin",
    "memberof": "src/WebChannelFacade.js~WebGroup",
    "static": false,
    "longname": "src/WebChannelFacade.js~WebGroup#autoRejoin",
    "access": "public",
    "description": "Enable/Desable the auto rejoin feature.",
    "lineNumber": 144,
    "type": {
      "nullable": null,
      "types": [
        "boolean"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 23,
    "kind": "member",
    "name": "onMessage",
    "memberof": "src/WebChannelFacade.js~WebGroup",
    "static": false,
    "longname": "src/WebChannelFacade.js~WebGroup#onMessage",
    "access": "public",
    "description": "This handler is called when a message has been received from the group.\n`id` is an identifier of the member who sent this message.\nand false if sent via {@link WebGroup#sendTo}.",
    "lineNumber": 157,
    "type": {
      "nullable": null,
      "types": [
        "function(id: number, data: DataType)"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 24,
    "kind": "member",
    "name": "onMemberJoin",
    "memberof": "src/WebChannelFacade.js~WebGroup",
    "static": false,
    "longname": "src/WebChannelFacade.js~WebGroup#onMemberJoin",
    "access": "public",
    "description": "This handler is called when a new member with `id` as identifier has joined the group.",
    "lineNumber": 175,
    "type": {
      "nullable": null,
      "types": [
        "function(id: number)"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 25,
    "kind": "member",
    "name": "onMemberLeave",
    "memberof": "src/WebChannelFacade.js~WebGroup",
    "static": false,
    "longname": "src/WebChannelFacade.js~WebGroup#onMemberLeave",
    "access": "public",
    "description": "This handler is called when a member with `id` as identifier hes left the group.",
    "lineNumber": 193,
    "type": {
      "nullable": null,
      "types": [
        "function(id: number)"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 26,
    "kind": "member",
    "name": "onStateChange",
    "memberof": "src/WebChannelFacade.js~WebGroup",
    "static": false,
    "longname": "src/WebChannelFacade.js~WebGroup#onStateChange",
    "access": "public",
    "description": "This handler is called when the group state has changed.",
    "lineNumber": 211,
    "type": {
      "nullable": null,
      "types": [
        "function(state: WebGroupState)"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 27,
    "kind": "member",
    "name": "onSignalingStateChange",
    "memberof": "src/WebChannelFacade.js~WebGroup",
    "static": false,
    "longname": "src/WebChannelFacade.js~WebGroup#onSignalingStateChange",
    "access": "public",
    "description": "This handler is called when the signaling state has changed.",
    "lineNumber": 229,
    "type": {
      "nullable": null,
      "types": [
        "function(state: SignalingState)"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 28,
    "kind": "method",
    "name": "join",
    "memberof": "src/WebChannelFacade.js~WebGroup",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/WebChannelFacade.js~WebGroup#join",
    "access": "public",
    "description": "Join the group identified by a key provided by one of the group member.\nIf the current {@link WebGroup#state} value is not {@link WebGroupState#LEFT} or\n{@link WebGroup#signalingState} value is not {@link SignalingState.CLOSED},\nthen do nothing.",
    "lineNumber": 251,
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": true,
        "name": "key",
        "description": "Will be generated if not provided"
      }
    ]
  },
  {
    "__docId__": 29,
    "kind": "method",
    "name": "invite",
    "memberof": "src/WebChannelFacade.js~WebGroup",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/WebChannelFacade.js~WebGroup#invite",
    "access": "public",
    "description": "Invite a bot server to join this group.",
    "lineNumber": 262,
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "url",
        "description": "Bot server URL (See {@link WebGroupBotServerOptions})"
      }
    ]
  },
  {
    "__docId__": 30,
    "kind": "method",
    "name": "leave",
    "memberof": "src/WebChannelFacade.js~WebGroup",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/WebChannelFacade.js~WebGroup#leave",
    "access": "public",
    "description": "Leave the group which means close channels with all members and connection\nwith the Signaling server.",
    "lineNumber": 273
  },
  {
    "__docId__": 31,
    "kind": "method",
    "name": "send",
    "memberof": "src/WebChannelFacade.js~WebGroup",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/WebChannelFacade.js~WebGroup#send",
    "access": "public",
    "description": "Broadcast a message to the group.",
    "lineNumber": 284,
    "params": [
      {
        "nullable": null,
        "types": [
          "DataType"
        ],
        "spread": false,
        "optional": false,
        "name": "data",
        "description": ""
      }
    ]
  },
  {
    "__docId__": 32,
    "kind": "method",
    "name": "sendTo",
    "memberof": "src/WebChannelFacade.js~WebGroup",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/WebChannelFacade.js~WebGroup#sendTo",
    "access": "public",
    "description": "Send a message to a particular group member.",
    "lineNumber": 296,
    "params": [
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "id",
        "description": "Member identifier"
      },
      {
        "nullable": null,
        "types": [
          "DataType"
        ],
        "spread": false,
        "optional": false,
        "name": "data",
        "description": "Message"
      }
    ]
  },
  {
    "__docId__": 33,
    "kind": "file",
    "name": "src/index.common.doc.js",
    "content": "import { LogLevel as Logs, setLogLevel as setLogs } from './misc/Util';\nimport { TopologyEnum } from './service/topology/Topology';\nimport { SignalingState as SigState } from './Signaling';\nimport { WebChannelState } from './WebChannelState';\nexport { WebGroup } from './WebChannelFacade';\n/**\n * Set log level for debugging utility. By default all logs are disabled.\n * @param {...LogLevel} levels\n */\nexport function setLogLevel(...levels) {\n    setLogs(levels);\n}\n/**\n * The state enum of the signaling server.\n */\nexport class SignalingState {\n    /**\n     * `0`: the connection is not yet open (equivalent to `WebSocket.CONNECTING`).\n     * @type {number}\n     */\n    static get CONNECTING() {\n        return SigState.CONNECTING;\n    }\n    /**\n     * `1`: the connection is open and ready to communicate (equivalent to `WebSocket.OPEN`).\n     * @type {number}\n     */\n    static get OPEN() {\n        return SigState.OPEN;\n    }\n    /**\n     * `2`: the connection is in the process of closing (equivalent to `WebSocket.CLOSING`).\n     * @type {number}\n     */\n    static get CLOSING() {\n        return SigState.CLOSING;\n    }\n    /**\n     * `3`: the connection is closed or couldn't be opened (equivalent to `WebSocket.CLOSED`).\n     * @type {number}\n     */\n    static get CLOSED() {\n        return SigState.CLOSED;\n    }\n    /**\n     * `4`: signaling server is checking wether you are still connected to the group. If it is not the case, then\n     * subscribs you to one of the group member in order to create a connection with him.\n     * @type {number}\n     */\n    static get CHECKING() {\n        return SigState.CHECKING;\n    }\n    /**\n     * `5`: a connection has been established with one of the group member or you are the only member of the group.\n     * From now the signaling is no longer needed, because the joining process will continue with a help of this member.\n     * @type {number}\n     */\n    static get CHECKED() {\n        return SigState.CHECKED;\n    }\n}\n/**\n * The state enum of {@link WebGroup}.\n */\nexport class WebGroupState {\n    /**\n     * `0`: you haven't joined the group yet.\n     * @type {number}\n     */\n    static get JOINING() {\n        return WebChannelState.JOINING;\n    }\n    /**\n     * `1`: you have sussessfully joined the group and ready to communicate.\n     * @type {number}\n     */\n    static get JOINED() {\n        return WebChannelState.JOINED;\n    }\n    /**\n     * `2`: you are about to leave the group.\n     * @type {number}\n     */\n    static get LEAVING() {\n        return WebChannelState.LEAVING;\n    }\n    /**\n     * `3`: you have sussessfully left the group.\n     * @type {number}\n     */\n    static get LEFT() {\n        return WebChannelState.LEFT;\n    }\n}\n/**\n * The topology enum. More topologies will be added in the future\n */\nexport class Topology {\n    /**\n     * Full mesh topology identifier.\n     * @type {number}\n     */\n    static get FULL_MESH() {\n        return TopologyEnum.FULL_MESH;\n    }\n}\n/**\n * The log level enum for debugging purposes.\n */\nexport class LogLevel {\n    /**\n     * Equals to `1`, allows logs for debug.\n     * @type {number}\n     */\n    static get DEBUG() {\n        return Logs.DEBUG;\n    }\n    /**\n     * Equals to `2`, logs for WebGroup module.\n     * @type {number}\n     */\n    static get WEB_GROUP() {\n        return Logs.WEB_GROUP;\n    }\n    /**\n     * Equals to `3`, logs for WebRTCBuilder module.\n     * @type {number}\n     */\n    static get WEBRTC() {\n        return Logs.WEBRTC;\n    }\n    /**\n     * Equals to `4`, logs for Channel module.\n     * @type {number}\n     */\n    static get CHANNEL() {\n        return Logs.CHANNEL;\n    }\n    /**\n     * Equals to `5`, logs for Topology module.\n     * @type {number}\n     */\n    static get TOPOLOGY() {\n        return Logs.TOPOLOGY;\n    }\n    /**\n     * Equals to `6`, logs for Signaling module.\n     * @type {number}\n     */\n    static get SIGNALING() {\n        return Logs.SIGNALING;\n    }\n    /**\n     * Equals to `7`, logs for ChannelBuilder module.\n     * @type {number}\n     */\n    static get CHANNEL_BUILDER() {\n        return Logs.CHANNEL_BUILDER;\n    }\n}\n/**\n * The options to be passed into {@link WebGroup} constructor.\n * @typedef {Object} WebGroupOptions\n * @property {Topology} [topology] Topology identifier\n * (Full mesh is the only one supported by Netflux for now).\n * @property {string} [signalingServer] Signaling URL for WebRTC.\n * @property {RTCConfiguration} [rtcConfiguration] Configuration for WebRTC.\n * @property {boolean} [autoRejoin] Whether to automatically rejoin the web group\n * on disconnect or not. Its value may be modified after {@link WebGroup}\n * instantiation at any time.\n */\n/**\n * The options to be passed into {@link WebGroupBotServer} constructor.\n * @typedef {Object} WebGroupBotServerOptions\n * @property {Topology} [topology] See WebGroupOptions.topology\n * @property {string} [signalingServer] See WebGroupOptions.signalingServer\n * @property {RTCConfiguration} [rtcConfiguration] See WebGroupOptions.rtcConfiguration\n * @property {boolean} [autoRejoin] See WebGroupOptions.autoRejoin\n * @property {Object} bot Server related options of the bot.\n * @property {NodeJSHttpServer|NodeJSHttpsServer} bot.server NodeJS http(s) server.\n * @property {string} [bot.url] Bot server URL.\n * @property {boolean} [bot.perMessageDeflate] Enable/disable permessage-deflate.\n */\n/**\n * @external {RTCConfiguration} https://developer.mozilla.org/en/docs/Web/API/RTCConfiguration\n */\n/**\n * @external {Uint8Array} https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Uint8Array\n */\n/**\n * @external {NodeJSHttpServer} https://nodejs.org/api/http.html#http_class_http_server\n */\n/**\n * @external {NodeJSHttpsServer} https://nodejs.org/api/https.html#https_class_https_server\n */\n",
    "static": true,
    "longname": "/home/philippe/workspace/netflux/docs/jsFromTs/src/index.common.doc.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 34,
    "kind": "function",
    "name": "setLogLevel",
    "memberof": "src/index.common.doc.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/index.common.doc.js~setLogLevel",
    "access": "public",
    "export": true,
    "importPath": "netflux/src/index.common.doc.js",
    "importStyle": "{setLogLevel}",
    "description": "Set log level for debugging utility. By default all logs are disabled.",
    "lineNumber": 10,
    "params": [
      {
        "nullable": null,
        "types": [
          "...LogLevel"
        ],
        "spread": true,
        "optional": false,
        "name": "levels",
        "description": ""
      }
    ]
  },
  {
    "__docId__": 35,
    "kind": "class",
    "name": "SignalingState",
    "memberof": "src/index.common.doc.js",
    "static": true,
    "longname": "src/index.common.doc.js~SignalingState",
    "access": "public",
    "export": true,
    "importPath": "netflux/src/index.common.doc.js",
    "importStyle": "{SignalingState}",
    "description": "The state enum of the signaling server.",
    "lineNumber": 16,
    "interface": false
  },
  {
    "__docId__": 36,
    "kind": "get",
    "name": "CONNECTING",
    "memberof": "src/index.common.doc.js~SignalingState",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/index.common.doc.js~SignalingState.CONNECTING",
    "access": "public",
    "description": "`0`: the connection is not yet open (equivalent to `WebSocket.CONNECTING`).",
    "lineNumber": 21,
    "type": {
      "nullable": null,
      "types": [
        "number"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 37,
    "kind": "get",
    "name": "OPEN",
    "memberof": "src/index.common.doc.js~SignalingState",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/index.common.doc.js~SignalingState.OPEN",
    "access": "public",
    "description": "`1`: the connection is open and ready to communicate (equivalent to `WebSocket.OPEN`).",
    "lineNumber": 28,
    "type": {
      "nullable": null,
      "types": [
        "number"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 38,
    "kind": "get",
    "name": "CLOSING",
    "memberof": "src/index.common.doc.js~SignalingState",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/index.common.doc.js~SignalingState.CLOSING",
    "access": "public",
    "description": "`2`: the connection is in the process of closing (equivalent to `WebSocket.CLOSING`).",
    "lineNumber": 35,
    "type": {
      "nullable": null,
      "types": [
        "number"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 39,
    "kind": "get",
    "name": "CLOSED",
    "memberof": "src/index.common.doc.js~SignalingState",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/index.common.doc.js~SignalingState.CLOSED",
    "access": "public",
    "description": "`3`: the connection is closed or couldn't be opened (equivalent to `WebSocket.CLOSED`).",
    "lineNumber": 42,
    "type": {
      "nullable": null,
      "types": [
        "number"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 40,
    "kind": "get",
    "name": "CHECKING",
    "memberof": "src/index.common.doc.js~SignalingState",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/index.common.doc.js~SignalingState.CHECKING",
    "access": "public",
    "description": "`4`: signaling server is checking wether you are still connected to the group. If it is not the case, then\nsubscribs you to one of the group member in order to create a connection with him.",
    "lineNumber": 50,
    "type": {
      "nullable": null,
      "types": [
        "number"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 41,
    "kind": "get",
    "name": "CHECKED",
    "memberof": "src/index.common.doc.js~SignalingState",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/index.common.doc.js~SignalingState.CHECKED",
    "access": "public",
    "description": "`5`: a connection has been established with one of the group member or you are the only member of the group.\nFrom now the signaling is no longer needed, because the joining process will continue with a help of this member.",
    "lineNumber": 58,
    "type": {
      "nullable": null,
      "types": [
        "number"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 42,
    "kind": "class",
    "name": "WebGroupState",
    "memberof": "src/index.common.doc.js",
    "static": true,
    "longname": "src/index.common.doc.js~WebGroupState",
    "access": "public",
    "export": true,
    "importPath": "netflux/src/index.common.doc.js",
    "importStyle": "{WebGroupState}",
    "description": "The state enum of {@link WebGroup}.",
    "lineNumber": 65,
    "interface": false
  },
  {
    "__docId__": 43,
    "kind": "get",
    "name": "JOINING",
    "memberof": "src/index.common.doc.js~WebGroupState",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/index.common.doc.js~WebGroupState.JOINING",
    "access": "public",
    "description": "`0`: you haven't joined the group yet.",
    "lineNumber": 70,
    "type": {
      "nullable": null,
      "types": [
        "number"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 44,
    "kind": "get",
    "name": "JOINED",
    "memberof": "src/index.common.doc.js~WebGroupState",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/index.common.doc.js~WebGroupState.JOINED",
    "access": "public",
    "description": "`1`: you have sussessfully joined the group and ready to communicate.",
    "lineNumber": 77,
    "type": {
      "nullable": null,
      "types": [
        "number"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 45,
    "kind": "get",
    "name": "LEAVING",
    "memberof": "src/index.common.doc.js~WebGroupState",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/index.common.doc.js~WebGroupState.LEAVING",
    "access": "public",
    "description": "`2`: you are about to leave the group.",
    "lineNumber": 84,
    "type": {
      "nullable": null,
      "types": [
        "number"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 46,
    "kind": "get",
    "name": "LEFT",
    "memberof": "src/index.common.doc.js~WebGroupState",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/index.common.doc.js~WebGroupState.LEFT",
    "access": "public",
    "description": "`3`: you have sussessfully left the group.",
    "lineNumber": 91,
    "type": {
      "nullable": null,
      "types": [
        "number"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 47,
    "kind": "class",
    "name": "Topology",
    "memberof": "src/index.common.doc.js",
    "static": true,
    "longname": "src/index.common.doc.js~Topology",
    "access": "public",
    "export": true,
    "importPath": "netflux/src/index.common.doc.js",
    "importStyle": "{Topology}",
    "description": "The topology enum. More topologies will be added in the future",
    "lineNumber": 98,
    "interface": false
  },
  {
    "__docId__": 48,
    "kind": "get",
    "name": "FULL_MESH",
    "memberof": "src/index.common.doc.js~Topology",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/index.common.doc.js~Topology.FULL_MESH",
    "access": "public",
    "description": "Full mesh topology identifier.",
    "lineNumber": 103,
    "type": {
      "nullable": null,
      "types": [
        "number"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 49,
    "kind": "class",
    "name": "LogLevel",
    "memberof": "src/index.common.doc.js",
    "static": true,
    "longname": "src/index.common.doc.js~LogLevel",
    "access": "public",
    "export": true,
    "importPath": "netflux/src/index.common.doc.js",
    "importStyle": "{LogLevel}",
    "description": "The log level enum for debugging purposes.",
    "lineNumber": 110,
    "interface": false
  },
  {
    "__docId__": 50,
    "kind": "typedef",
    "name": "WebGroupOptions",
    "memberof": "src/index.common.doc.js",
    "static": true,
    "longname": "src/index.common.doc.js~WebGroupOptions",
    "access": "public",
    "description": "The options to be passed into {@link WebGroup} constructor.",
    "properties": [
      {
        "nullable": null,
        "types": [
          "Topology"
        ],
        "spread": false,
        "optional": true,
        "name": "topology",
        "description": "Topology identifier\n(Full mesh is the only one supported by Netflux for now)."
      },
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": true,
        "name": "signalingServer",
        "description": "Signaling URL for WebRTC."
      },
      {
        "nullable": null,
        "types": [
          "RTCConfiguration"
        ],
        "spread": false,
        "optional": true,
        "name": "rtcConfiguration",
        "description": "Configuration for WebRTC."
      },
      {
        "nullable": null,
        "types": [
          "boolean"
        ],
        "spread": false,
        "optional": true,
        "name": "autoRejoin",
        "description": "Whether to automatically rejoin the web group\non disconnect or not. Its value may be modified after {@link WebGroup}\ninstantiation at any time."
      }
    ],
    "type": {
      "types": [
        "Object"
      ],
      "optional": false,
      "name": "WebGroupOptions"
    }
  },
  {
    "__docId__": 51,
    "kind": "typedef",
    "name": "WebGroupBotServerOptions",
    "memberof": "src/index.common.doc.js",
    "static": true,
    "longname": "src/index.common.doc.js~WebGroupBotServerOptions",
    "access": "public",
    "description": "The options to be passed into {@link WebGroupBotServer} constructor.",
    "properties": [
      {
        "nullable": null,
        "types": [
          "Topology"
        ],
        "spread": false,
        "optional": true,
        "name": "topology",
        "description": "See WebGroupOptions.topology"
      },
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": true,
        "name": "signalingServer",
        "description": "See WebGroupOptions.signalingServer"
      },
      {
        "nullable": null,
        "types": [
          "RTCConfiguration"
        ],
        "spread": false,
        "optional": true,
        "name": "rtcConfiguration",
        "description": "See WebGroupOptions.rtcConfiguration"
      },
      {
        "nullable": null,
        "types": [
          "boolean"
        ],
        "spread": false,
        "optional": true,
        "name": "autoRejoin",
        "description": "See WebGroupOptions.autoRejoin"
      },
      {
        "nullable": null,
        "types": [
          "Object"
        ],
        "spread": false,
        "optional": false,
        "name": "bot",
        "description": "Server related options of the bot."
      },
      {
        "nullable": null,
        "types": [
          "NodeJSHttpServer",
          "NodeJSHttpsServer"
        ],
        "spread": false,
        "optional": false,
        "name": "bot.server",
        "description": "NodeJS http(s) server."
      },
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": true,
        "name": "bot.url",
        "description": "Bot server URL."
      },
      {
        "nullable": null,
        "types": [
          "boolean"
        ],
        "spread": false,
        "optional": true,
        "name": "bot.perMessageDeflate",
        "description": "Enable/disable permessage-deflate."
      }
    ],
    "type": {
      "types": [
        "Object"
      ],
      "optional": false,
      "name": "WebGroupBotServerOptions"
    }
  },
  {
    "__docId__": 52,
    "kind": "external",
    "name": "RTCConfiguration",
    "externalLink": "https://developer.mozilla.org/en/docs/Web/API/RTCConfiguration",
    "memberof": "src/index.common.doc.js",
    "static": true,
    "longname": "src/index.common.doc.js~RTCConfiguration",
    "access": "public",
    "description": ""
  },
  {
    "__docId__": 53,
    "kind": "external",
    "name": "Uint8Array",
    "externalLink": "https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Uint8Array",
    "memberof": "src/index.common.doc.js",
    "static": true,
    "longname": "src/index.common.doc.js~Uint8Array",
    "access": "public",
    "description": ""
  },
  {
    "__docId__": 54,
    "kind": "external",
    "name": "NodeJSHttpServer",
    "externalLink": "https://nodejs.org/api/http.html#http_class_http_server",
    "memberof": "src/index.common.doc.js",
    "static": true,
    "longname": "src/index.common.doc.js~NodeJSHttpServer",
    "access": "public",
    "description": ""
  },
  {
    "__docId__": 55,
    "kind": "external",
    "name": "NodeJSHttpsServer",
    "externalLink": "https://nodejs.org/api/https.html#https_class_https_server",
    "memberof": "src/index.common.doc.js",
    "static": true,
    "longname": "src/index.common.doc.js~NodeJSHttpsServer",
    "access": "public",
    "description": ""
  },
  {
    "__docId__": 56,
    "kind": "get",
    "name": "DEBUG",
    "memberof": "src/index.common.doc.js~LogLevel",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/index.common.doc.js~LogLevel.DEBUG",
    "access": "public",
    "description": "Equals to `1`, allows logs for debug.",
    "lineNumber": 115,
    "type": {
      "nullable": null,
      "types": [
        "number"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 57,
    "kind": "get",
    "name": "WEB_GROUP",
    "memberof": "src/index.common.doc.js~LogLevel",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/index.common.doc.js~LogLevel.WEB_GROUP",
    "access": "public",
    "description": "Equals to `2`, logs for WebGroup module.",
    "lineNumber": 122,
    "type": {
      "nullable": null,
      "types": [
        "number"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 58,
    "kind": "get",
    "name": "WEBRTC",
    "memberof": "src/index.common.doc.js~LogLevel",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/index.common.doc.js~LogLevel.WEBRTC",
    "access": "public",
    "description": "Equals to `3`, logs for WebRTCBuilder module.",
    "lineNumber": 129,
    "type": {
      "nullable": null,
      "types": [
        "number"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 59,
    "kind": "get",
    "name": "CHANNEL",
    "memberof": "src/index.common.doc.js~LogLevel",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/index.common.doc.js~LogLevel.CHANNEL",
    "access": "public",
    "description": "Equals to `4`, logs for Channel module.",
    "lineNumber": 136,
    "type": {
      "nullable": null,
      "types": [
        "number"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 60,
    "kind": "get",
    "name": "TOPOLOGY",
    "memberof": "src/index.common.doc.js~LogLevel",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/index.common.doc.js~LogLevel.TOPOLOGY",
    "access": "public",
    "description": "Equals to `5`, logs for Topology module.",
    "lineNumber": 143,
    "type": {
      "nullable": null,
      "types": [
        "number"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 61,
    "kind": "get",
    "name": "SIGNALING",
    "memberof": "src/index.common.doc.js~LogLevel",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/index.common.doc.js~LogLevel.SIGNALING",
    "access": "public",
    "description": "Equals to `6`, logs for Signaling module.",
    "lineNumber": 150,
    "type": {
      "nullable": null,
      "types": [
        "number"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 62,
    "kind": "get",
    "name": "CHANNEL_BUILDER",
    "memberof": "src/index.common.doc.js~LogLevel",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/index.common.doc.js~LogLevel.CHANNEL_BUILDER",
    "access": "public",
    "description": "Equals to `7`, logs for ChannelBuilder module.",
    "lineNumber": 157,
    "type": {
      "nullable": null,
      "types": [
        "number"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "kind": "index",
    "content": "# Netflux\n\n![Netflux logo][logo]\n\nUniversal Javascript **peer to peer** transport API for client and server.\n\nSecure and fault tolerant full mesh peer to peer network based on **RTCDataChannel** and **WebSocket**.\n\nSend/receive **String** and **Uint8Array** data types.\n\nDocumentation: <https://coast-team.github.io/netflux>\n\n[![version](https://img.shields.io/npm/v/netflux.svg?style=flat-square)](https://www.npmjs.com/package/netflux)\n[![travis](https://travis-ci.org/coast-team/netflux.svg?branch=master)](https://travis-ci.org/coast-team/netflux)\n\n[![bithound](https://www.bithound.io/github/coast-team/netflux/badges/score.svg)](https://www.bithound.io/github/coast-team/netflux)\n[![codeclimate](https://codeclimate.com/github/coast-team/netflux/badges/gpa.svg)](https://codeclimate.com/github/coast-team/netflux)\n[![documentation](https://coast-team.github.io/netflux/badge.svg)](https://coast-team.github.io/netflux)\n\n[![commitizen](https://img.shields.io/badge/commitizen-friendly-brightgreen.svg?style=flat-square)](http://commitizen.github.io/cz-cli)\n[![semantic-release](https://img.shields.io/badge/%20%20%F0%9F%93%A6%F0%9F%9A%80-semantic--release-e10079.svg?style=flat-square)](https://github.com/semantic-release/semantic-release)\n[![gitter](https://img.shields.io/badge/GITTER-join%20chat-green.svg?style=flat-square)](https://gitter.im/coast-team/netflux?utm_source=badge&utm_medium=badge&utm_campaign=pr-badge&utm_content=badge)\n\n![Netflux example][netflux_example]\n\n## Features\n\n* Peer to peer full mesh network which accepts connection failures between some peers.\n* If connection between two members failed, other members will retransmit messages for them.\n* Automatic rejoin the group if connection lost.\n* Automatic selection between [WebSocket][websocket] & [RTCDataChannel][rtcdatachannel].\n* Possible to have mixed members: clients (Chrome, Firefox) and servers (NodeJS bot).\n* Send private or broadcast [String][string], [Uint8Array][uint8array] data types.\n* Possible to send data > 1MB.\n* All connections are encrypted.\n* Full control over WebRTC servers: Signaling, STUN and TURN.\n  * Deploy your own Signaling server ([Sigver][sigver]) or use one provided by default.\n  * Configure STUN and TURN servers.\n* Small Signaling server payload.\n* Signaling server is used only to establish connection between two peers, no user data is passing through it.\n* Universal API (works in Chrome/Firefox and NodeJS).\n* TypeScript declaration files are included.\n* Simple and familiar API usage.\n* 4 builds (ES5 code):\n  * `dist/netflux.cjs.js` CommonJS format for NodeJS (see _package.json#main_).\n  * `dist/esm/index.node.js` ES module format for NodeJS (see _package.json#module_).\n  * `dist/esm/index.browser.js` ES module format for browsers (see _package.json#browser_).\n  * `dist/netflux.umd.js` UMD format for browsers.\n\n## Usage\n\nHere is a basic usage example for client and server (checkout the [documenation](https://coast-team.github.io/netflux) for more details).\n\n> It is possible to have only clients without any bot server as his is not a mandatory member, but like any other group member.\n\n### Client\n\n```javascript\nimport { WebGroup, WebGroupState } from 'netflux'\n\n// Create instance and set callbacks\nconst wg = new WebGroup()\nwg.onMemberJoin = (id) => {\n  console.log('Member ' + id + ' has joined')\n  console.log('All members are: ', wg.members)\n}\nwg.onMemberLeave = (id) => {\n  console.log('Member ' + id + ' has left')\n  console.log('All members are: ', wg.members)\n}\nwg.onMessage = (id, data) => {\n  console.log(`Message from ${id} group member`, data)\n}\nwg.onStateChange = (state) => {\n  console.log('The new Group state is ', state)\n  switch (state) {\n    case WebGroupState.JOINING:\n      // Do something\n      break\n    case WebGroupState.JOINED:\n      // Do something\n      // For example inviting a bot...\n      wg.invite('BOT_SERVER_WEB_SOCKET_URL')\n      break\n    case WebGroupState.LEAVING:\n      // Do something\n      break\n    case WebGroupState.LEFT:\n      // Do something\n      break\n  }\n}\n\n// Join the group\nwg.join('MY_UNIQUE_KEY_FOR_THE_GROUP')\n```\n\n### Bot Server\n\n```javascript\nimport { WebGroupBotServer } from 'netflux'\nconst http = require('http') // https is also possible\nconst server = http.createServer()\n\nconst bot = new WebGroupBotServer({\n  server: server,\n  webGroupOptions: {\n    // Any WebGroup options like for a client\n  },\n})\n\nbot.onWebGroup = (wg) => {\n  // New instance of a WebGroup (Someone has invited this bot).\n  // See example above for client as it is the same API.\n}\n\nserver.listen(BOT_PORT, _BOT_HOST)\n// A client may invite this bot with the following URL: 'ws://BOT_HOST:BOT_PORT'\n```\n\n## Demo\n\nNetflux is used by our team for Multi User Text Editor ([MUTE repo](https://github.com/coast-team/mute)) development. The demo version is available on: <https://coedit.re>.\n\n[websocket]: https://developer.mozilla.org/en/docs/Web/API/WebSocket\n[rtcdatachannel]: https://developer.mozilla.org/en/docs/Web/API/RTCDataChannel\n[string]: https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/String\n[uint8array]: https://developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/Uint8Array\n[sigver]: https://github.com/coast-team/sigver\n[commitizen]: https://img.shields.io/badge/commitizen-friendly-brightgreen.svg?style=flat-square\n[commitizen-url]: http://commitizen.github.io/cz-cli\n[bithound]: https://www.bithound.io/github/coast-team/netflux/badges/score.svg\n[bithound-url]: https://www.bithound.io/github/coast-team/netflux\n[codeclimate]: https://codeclimate.com/github/coast-team/netflux/badges/gpa.svg\n[codeclimate-url]: https://codeclimate.com/github/coast-team/netflux\n[coverage]: https://codeclimate.com/github/coast-team/netflux/badges/coverage.svg\n[coverage-url]: https://codeclimate.com/github/coast-team/netflux/coverage\n[doc]: https://coast-team.github.io/netflux/badge.svg\n[doc-url]: https://coast-team.github.io/netflux/netflux\n[logo]: manual/asset/logo_760px.png\n[netflux_example]: manual/asset/example.png\n",
    "longname": "/home/philippe/workspace/netflux/README.md",
    "name": "./README.md",
    "static": true,
    "access": "public"
  },
  {
    "kind": "manualIndex",
    "globalIndex": false,
    "content": null,
    "longname": "",
    "static": true,
    "access": "public"
  },
  {
    "kind": "manualAsset",
    "longname": "/home/philippe/workspace/netflux/manual/asset",
    "name": "./manual/asset",
    "static": true,
    "access": "public"
  },
  {
    "kind": "manual",
    "longname": "/home/philippe/workspace/netflux/manual/installation.md",
    "name": "./manual/installation.md",
    "content": "# Installation\n\n## NPM\n\n```shell\nnpm install -S netflux\n```\n\nNetflux has an optional peer dependency: `wrtc`. This package provides WebRTC API in NodeJS, but for now it is not in use as more tests needed. Checkout [wrtc repository](https://github.com/js-platform/node-webrtc) for more info on it.\n\n## What you need\n\nSignaling server is the only mandatory server for Netflux, but for a fully functional peer to peer network which suits all use cases you also need STUN and TURN servers.\n\n> Netflux comes with Signaling and STUN servers by default for easier quickstart.\n\n### Signaling server\n\n> **Default**: `wss://signaling.netflux.coedit.re`\n\nThe only signaling mechanism which is supported by Netflux for now is [Sigver](https://github.com/coast-team/sigver) (NodeJS WebSocket server developed by us).\n\n> **TIP**: Your own instance of Sigver for production is recommended.\n\n### STUN server\n\n**Default**: `stun:stun3.l.google.com:19302`\n\nThere are many other free STUN servers available in the Web.\n\n### TURN server\n\nThere are no free TURN servers available in the Web. Two solutions exist:\n\n* Rent one. Checkout [Xirsys](https://xirsys.com/) for example.\n* Deploy your own instance. The paragraphe below provides a guide on how to deploy and configure [`coturn`](https://github.com/coturn/coturn) open source TURN server. Also checkout [_Choosing a TURN server_](https://rtcquickstart.org/guide/multi/turn-server-choice.html) for a list of open source TURN servers.\n\n## How to deploy STUN/TURN servers\n\nThis guide present a basic configuration for [coturn](https://github.com/coturn/coturn).\nIt allow us to deploy our own STUN/TURN server in order to connect users behind a NAT or Firewall.\n\nFor more informations or options, see coturn [documentation](https://github.com/coturn/coturn/wiki/README).\n\nOn most Linux Distribution, the package is in the repo:\n`apt-get install coturn`\n\nYou must have SQLite installed:\n`sudo apt-get install sqlite3 libsqlite3-dev`\n\nConfig file can be found at:\n`/etc/turnserver.conf`\n\nSimple config file should look like this:\n\n```bash\n# you can listen ports 3478 and 5349 instead of 80/443\nlistening-port=80\ntls-listening-port=443\n\nlistening-ip=YOUR_IP_ADDRESS\nrelay-ip=YOUR_IP_ADDRESS\n\nrealm=YOUR_DOMAIND.COM\nserver-name=OUR_DOMAIND.COM\n\nfingerprint\n\n# webRTC authentication method\nlt-cred-mech\n\n# WebRTC credentials\nuser=YOUR_USER_NAME:YOUR_PASSWORD\n\n# Quota\ntotal-quota=100\nbps-capacity=0\nstable-nonce\n\n# Add ssl certificate for your server\ncert=/etc/ssl/certificate.pem\npkey=/etc/ssl/private.key\ncipher-list=\"ECDH+AESGCM:DH+AESGCM:ECDH+AES256:DH+AES256:ECDH+AES128:!DH+AES:!ECDH+3DES:!DH+3DES:!RSA+AES:!RSA+3DES:!ADH:!AECDH:!MD5\"\nno-loopback-peers\nno-multicast-peers\nno-stdout-log\n```\n\nIf you don't have any SSL certificate, you may use [Let's Encrypt](https://letsencrypt.org/).\n\nLaunch server:\n\n```turnserver`\n\nor in daemon:\n\n`turnserver -o`\n\nVerify that the server is up and running with [Trickle ICE](https://webrtc.github.io/samples/src/content/peerconnection/trickle-ice/).\n",
    "static": true,
    "access": "public"
  },
  {
    "kind": "manual",
    "longname": "/home/philippe/workspace/netflux/manual/usage.md",
    "name": "./manual/usage.md",
    "content": "# Usage\n\nThere are 4 builds (all ES5 code):\n\n- `dist/netflux.cjs.js` CommonJS format for NodeJS.\n- `dist/esm/netflux.node.js` ECMAScript 6 module format for NodeJS.\n- `dist/esm/netflux.browser.js` ECMAScript 6 module format for browsers.\n- `dist/netflux.umd.js` UMD format for browsers.\n\nThe `package.json` contains the following fields:\n\n```json\n...\n\"main\": \"dist/netflux.cjs.js\",\n\"module\": \"dist/esm/index.node.js\",\n\"browser\": \"dist/esm/index.browser.js\",\n...\n```\n\nAll builds are either for NodeJS or for Browser environment.\n\n**For browser environment** exported members are:\n\n- `WebGroup` class\n- `WebGroupState` enum\n- `SignalingState` enum\n- `Topology` enum\n- `DataType` type\n- `WebGroupOption` type\n\n**For NodeJS environment** exported members are the same as for browser plus:\n\n- `WebGroupBotServer` class\n- `WebGroupBotServerOptions` type.\n\n## CommonJS\n\n`dist/netflux.cjs.js` - CommonJS format, built for NodeJS.\n\n```Javascript\n// NodeJS\nconst netflux = require('netflux')\nvar wg = new netflux.WebGroup()\n```\n\n## ES module\n\n`esm/index.node.js` and `esm/index.browser.js` are suitable for Webpack, Browserify or any alike, which also undersands `package.json#module` and `package.json#module` properties respectively and can parse ES modules.\n\n`esm/index.node.js` is build for NodeJS: contains all exported API members and all necessary polyfills for NodeJS environment.\n\n`esm/index.browser.js`  si build for browsers.\n\n```javascript\nexport {WebGroup, WebGroupState, WebGroupBotServer, WebGroupBotServerOptions} from 'netflux'\nconst wg = new WebGroup()\n```\n\n## UMD\n\n`dist/netflux.umd.js` - Universal Module Definition format is compatible with AMD, CommonJS and \"global\" modules. Built for browser and suitable for Webpack, Browserify and any other who\nalso understands `package.json#browser` property.\n\n```html\n<!-- Browser global usage example -->\n<script src=\"netflux.es5.umd.js\">\n  window.netflux !== undefined // true\n  var wg = new window.netflux.WebGroup()\n</script>\n```\n\n## Configuration\n\nFor a `WebGroup` object all options are optional.\n\n```javascript\n// Example:\nconst wg = new WebGroup({\n  signalingURL: 'MY_SIGNALING_URL',\n  rtcConfiguration: {\n    iceServers: [\n      { urls: 'stun:mystun.org' },\n      {\n        urls: ['turn:myturn.org?transport=udp', 'turn:myturn.org?transport=tcp'],\n        username: 'user',\n        password: 'password'\n      }\n    ]\n  }\n})\n```\n\nFor `WebGroupBotServer` the server option is mandatory.\n\n```javascript\n// Example:\nconst http = require('http')\nconst myServer = http.createServer()\nconst wg = new WebGroupBotServer({\n  server: myServer,\n  signalingServer: 'MY_SIGNALING_URL',\n  webGroupOptions: {\n    rtcConfiguration: {\n    iceServers: [\n      { urls: 'stun:mystun.org' },\n      {\n        urls: ['turn:myturn.org?transport=udp', 'turn:myturn.org?transport=tcp'],\n        username: 'user',\n        password: 'password'\n      }\n    ]\n  }\n  }\n})\n```\n",
    "static": true,
    "access": "public"
  },
  {
    "kind": "manual",
    "longname": "/home/philippe/workspace/netflux/manual/knownobstacles.md",
    "name": "./manual/knownobstacles.md",
    "content": "# Known WebRTC obstacles\n\nConnection establishment over WebRTC may ancounter different obstacles like NAT, Firewall, port blocking. But besides network obstacles there is also browser configuration that may prevent from connection creation.\n\n## Firefox extensions\n\nSome extensions for Firefox (Privacy Badger for instance) modify WebRTC configuration in browser. Checkout `about:config` and look for `peerconnection.ice`. If the _Status_ column is _default_ then the parameter was not modified.\n",
    "static": true,
    "access": "public"
  },
  {
    "kind": "manual",
    "longname": "/home/philippe/workspace/netflux/manual/faq.md",
    "name": "./manual/faq.md",
    "content": "# FAQ\n\n## How Netflux chooses between `RTCDataChannel` and `WebSocket`\n\nNetflux operates with `RTCDataChannel` (WebRTC) and `WebSocket` connection technologies.\n\nTechnically `RTCDataChannel` may be established between:\n\n* Browser and Browser.\n* Browser and Server.\n* Server and Server.\n\nOn the other hand, a `WebSocket` may be created only between:\n\n* Browser and Server.\n* Server and Server.\n\nBut in practice:\n\n* All modern browsers support `WebSocket` (Chrome, Firefox, Edge, Safary etc.), but only some of them support `RTCDataChannel` (Chrome, Firefox, Safari soon and Edge one day maybe).\n* Servers may or may not listen on `WebSocket` or connect over `WebSocket` and may or may not support `RTCDataChannel`.\n\nThis technical diversity pushes us to try all possibilities in order to create a connection between two peers based on their capabilities.\n\nBetween two peers, there is always one who initiates the connection, while the other is in a passive state. Lets say peer _A_ wants to connect to peer _B_ (i.e. _A_ is the initiator).\n\nThe following algorithm is the same for _A_ and _B_ and is executed each time a `message` is received. It runs through all possiblities in order to establish a connection between these peers (i.e. `return SUCCESS` if the connection succeed and `return FAILED` otherwise). It is important that the initiator peer (i.e. A) must be notified about the algorithm's result, while for the second peer (who is in the passive state) this information has no importance.\n\n`message` variable below persistes the state of the actions for both peers. It is updated by both and is exchanged between them.\n\n```pseudocode\n// Pseudocode:\n// I received a `message` from another peer\n\nif anotherPeerIsListeningOnWebSocketAndIHaveNotTriedToConnectYet(message)\n  if WebSocket connection succeed\n    return SUCCESS\n  else\n    update(message)\n\nif iAmListeningOnWebSocketAndAnotherPeerHasNotTriedToConnectYet(message)\n  send(message)\n  return\n\nif bothPeersSupportRTCDataChannel(message)\n  if iHaveNotTriedToConnectYet(message)\n    if RTCDataChannel connection succeed\n      return SUCCESS\n    else\n      update(message)\n  if anotherPeerHasNotTriedToConnectYet(message)\n    send(message)\n    return\n\nif iAmTheInitiator(message)\n  return FAILED\nelse\n  send(message)\n```\n",
    "static": true,
    "access": "public"
  },
  {
    "__docId__": 63,
    "kind": "testFile",
    "name": "test/functional/1member.test.js",
    "content": "/// <reference types='jasmine' />\nimport { SignalingState, Topology, WebGroup, WebGroupState } from '../../src/index.browser';\nimport { areTheSame, cleanWebGroup, SIGNALING_URL, wait } from '../util/helper';\nconst WebGroupOptions = {\n    signalingServer: SIGNALING_URL,\n    autoRejoin: false,\n};\n/** @test {WebGroup} */\ndescribe('1 member', () => {\n    describe('🙂', () => {\n        let wg1;\n        /** @test {WebGroup#constructor} */\n        it('constructor', () => {\n            const wg = new WebGroup({ signalingServer: SIGNALING_URL });\n            // Check members\n            const id = Reflect.getOwnPropertyDescriptor(wg, 'id');\n            expect(id).toBeDefined();\n            expect(typeof wg.id).toBe('number');\n            expect(id.set).toBeUndefined();\n            const myId = Reflect.getOwnPropertyDescriptor(wg, 'myId');\n            expect(myId).toBeDefined();\n            expect(typeof wg.myId).toBe('number');\n            expect(myId.set).toBeUndefined();\n            const key = Reflect.getOwnPropertyDescriptor(wg, 'key');\n            expect(key).toBeDefined();\n            expect(wg.key).toBe('');\n            expect(key.set).toBeUndefined();\n            const members = Reflect.getOwnPropertyDescriptor(wg, 'members');\n            expect(members).toBeDefined();\n            expect(wg.members).toEqual([wg.myId]);\n            expect(members.set).toBeUndefined();\n            const topology = Reflect.getOwnPropertyDescriptor(wg, 'topology');\n            expect(topology).toBeDefined();\n            expect(wg.topology).toBe(Topology.FULL_MESH);\n            expect(topology.set).toBeUndefined();\n            const state = Reflect.getOwnPropertyDescriptor(wg, 'state');\n            expect(state).toBeDefined();\n            expect(wg.state).toBe(WebGroupState.LEFT);\n            expect(state.set).toBeUndefined();\n            const signalingState = Reflect.getOwnPropertyDescriptor(wg, 'signalingState');\n            expect(signalingState).toBeDefined();\n            expect(wg.signalingState).toBe(SignalingState.CLOSED);\n            expect(signalingState.set).toBeUndefined();\n            const signalingServer = Reflect.getOwnPropertyDescriptor(wg, 'signalingServer');\n            expect(signalingServer).toBeDefined();\n            expect(wg.signalingServer).toBe(SIGNALING_URL);\n            expect(signalingServer.set).toBeUndefined();\n            expect(wg.autoRejoin).toBeTruthy();\n            wg.autoRejoin = false;\n            expect(wg.autoRejoin).toBeFalsy();\n            // Check event handlers\n            expect(wg.onMemberJoin).toBeUndefined();\n            expect(wg.onMemberLeave).toBeUndefined();\n            expect(wg.onMessage).toBeUndefined();\n            expect(wg.onStateChange).toBeUndefined();\n            expect(wg.onSignalingStateChange).toBeUndefined();\n            // Check methods\n            expect(typeof wg.join).toBe('function');\n            expect(typeof wg.invite).toBe('function');\n            expect(typeof wg.leave).toBe('function');\n            expect(typeof wg.send).toBe('function');\n            expect(typeof wg.sendTo).toBe('function');\n        });\n        /** @test {WebGroup#join} */\n        describe('joining', () => {\n            beforeEach(() => {\n                wg1 = new WebGroup(WebGroupOptions);\n            });\n            afterEach((done) => {\n                cleanWebGroup(wg1);\n                if (wg1.state !== WebGroupState.LEFT) {\n                    wg1.onStateChange = (state) => {\n                        if (state === WebGroupState.LEFT) {\n                            done();\n                        }\n                    };\n                    wg1.leave();\n                }\n                else {\n                    cleanWebGroup(wg1);\n                    done();\n                }\n            });\n            /** @test {WebGroup#onSignalingStateChange} */\n            it('should change the Signaling state', (done) => {\n                let called = 0;\n                const states = [];\n                const expectedStates = [\n                    SignalingState.CONNECTING,\n                    SignalingState.OPEN,\n                    SignalingState.CHECKING,\n                    SignalingState.CHECKED,\n                ];\n                wg1.onSignalingStateChange = (state) => {\n                    called++;\n                    states.push(state);\n                    if (called === expectedStates.length) {\n                        wait(1000).then(() => {\n                            expect(states).toEqual(expectedStates);\n                            expect(called).toEqual(expectedStates.length);\n                            expect(wg1.signalingState).toEqual(SignalingState.CHECKED);\n                            done();\n                        });\n                    }\n                };\n                // Start joining\n                wg1.join();\n            });\n            /** @test {WebGroup#onStateChange} */\n            it('should change the WebGroup state', (done) => {\n                let called = 0;\n                const states = [];\n                const expectedStates = [WebGroupState.JOINING, WebGroupState.JOINED];\n                wg1.onStateChange = (state) => {\n                    called++;\n                    states.push(state);\n                    if (called === expectedStates.length) {\n                        wait(1000).then(() => {\n                            expect(states).toEqual(expectedStates);\n                            expect(called).toEqual(expectedStates.length);\n                            expect(wg1.state).toEqual(WebGroupState.JOINED);\n                            done();\n                        });\n                    }\n                };\n                // Start joining\n                wg1.join();\n            });\n            /** @test {WebGroup#onMemberJoin} */\n            it('should NOT be notified about new member', (done) => {\n                let called1 = 0;\n                wg1.onMemberJoin = () => called1++;\n                wg1.onStateChange = (state) => {\n                    if (state === WebGroupState.JOINED) {\n                        wait(1000).then(() => {\n                            expect(called1).toEqual(0);\n                            done();\n                        });\n                    }\n                };\n                // Start joining\n                wg1.join();\n            });\n            it('should have the same members, WebGroup id, topology and NOT empty key once joined', (done) => {\n                const members = Array.from(wg1.members);\n                const myId = wg1.myId;\n                const id = wg1.id;\n                const topology = wg1.topology;\n                wg1.onStateChange = (state) => {\n                    if (state === WebGroupState.JOINED) {\n                        expect(areTheSame(wg1.members, members)).toBeTruthy();\n                        expect(myId).toEqual(wg1.myId);\n                        expect(id).toEqual(wg1.id);\n                        expect(topology).toEqual(wg1.topology);\n                        expect(wg1.key).not.toEqual('');\n                        wait(1000).then(() => {\n                            expect(areTheSame(wg1.members, members)).toBeTruthy();\n                            expect(myId).toEqual(wg1.myId);\n                            expect(id).toEqual(wg1.id);\n                            expect(topology).toEqual(wg1.topology);\n                            expect(wg1.key).not.toEqual('');\n                            done();\n                        });\n                    }\n                };\n                // Start joining\n                wg1.join();\n            });\n            /** @test {WebGroup#join} */\n            it('should join with the specified key', (done) => {\n                const key = 'ArtIsLongLifeIsShort';\n                const wg = new WebGroup(WebGroupOptions);\n                wg.onStateChange = (state) => {\n                    if (state === WebGroupState.JOINED) {\n                        expect(wg.key).toEqual(key);\n                        wg.leave();\n                        done();\n                    }\n                };\n                // Start joining\n                wg.join(key);\n            });\n        });\n        describe('leaving', () => {\n            beforeEach((done) => {\n                wg1 = new WebGroup(WebGroupOptions);\n                wg1.onStateChange = (state) => {\n                    if (state === WebGroupState.JOINED) {\n                        cleanWebGroup(wg1);\n                        done();\n                    }\n                };\n                wg1.join();\n            });\n            afterEach(() => cleanWebGroup(wg1));\n            /** @test {WebGroup#leave} */\n            it('should have the same members, WebGroup id, topology and an empty key', (done) => {\n                const members = Array.from(wg1.members);\n                const myId = wg1.myId;\n                const id = wg1.id;\n                const topology = wg1.topology;\n                wg1.onStateChange = (state) => {\n                    if (state === WebGroupState.LEFT) {\n                        expect(areTheSame(wg1.members, members)).toBeTruthy();\n                        expect(myId).toEqual(wg1.myId);\n                        expect(id).toEqual(wg1.id);\n                        expect(topology).toEqual(wg1.topology);\n                        expect(wg1.key).toEqual('');\n                        wait(1000).then(() => {\n                            expect(areTheSame(wg1.members, members)).toBeTruthy();\n                            expect(myId).toEqual(wg1.myId);\n                            expect(id).toEqual(wg1.id);\n                            expect(topology).toEqual(wg1.topology);\n                            expect(wg1.key).toEqual('');\n                            done();\n                        });\n                    }\n                };\n                // Start leaving\n                wg1.leave();\n            });\n            /** @test {WebGroup#onMemberLeave} */\n            it('should be NOT notified about left member', (done) => {\n                let called1 = 0;\n                wg1.onMemberJoin = () => called1++;\n                wg1.onStateChange = (state) => {\n                    if (state === WebGroupState.LEFT) {\n                        wait(1000).then(() => {\n                            expect(called1).toEqual(0);\n                            done();\n                        });\n                    }\n                };\n                // Start leaving\n                wg1.leave();\n            });\n            /** @test {WebGroup#onStateChange} */\n            it('should change the WebGroup state', (done) => {\n                let called1 = 0;\n                const states = [];\n                const expectedStates = [WebGroupState.LEAVING, WebGroupState.LEFT];\n                wg1.onStateChange = (state) => {\n                    states.push(state);\n                    called1++;\n                    if (state === WebGroupState.LEFT) {\n                        wait(1000).then(() => {\n                            expect(called1).toEqual(2);\n                            expect(states).toEqual(expectedStates);\n                            expect(state).toEqual(WebGroupState.LEFT);\n                            done();\n                        });\n                    }\n                };\n                // Start leaving\n                wg1.leave();\n            });\n            /** @test {WebGroup#onSignalingStateChange} */\n            it('should change the Signaling state', (done) => {\n                let called1 = 0;\n                const states = [];\n                const expectedStates = [SignalingState.CLOSING, SignalingState.CLOSED];\n                wg1.onSignalingStateChange = (state) => {\n                    states.push(state);\n                    called1++;\n                    wait(1000).then(() => {\n                        expect(called1).toEqual(2);\n                        expect(states).toEqual(expectedStates);\n                        done();\n                    });\n                };\n                // Start leaving\n                wg1.leave();\n            });\n        });\n    });\n});\n",
    "static": true,
    "longname": "/home/philippe/workspace/netflux/docs/jsFromTs/test/functional/1member.test.js",
    "access": null,
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 64,
    "kind": "test",
    "name": "describe0",
    "testId": 0,
    "memberof": "test/functional/1member.test.js",
    "testDepth": 0,
    "static": true,
    "longname": "test/functional/1member.test.js~describe0",
    "access": null,
    "description": "1 member",
    "lineNumber": 9,
    "testTargets": [
      "WebGroup"
    ]
  },
  {
    "__docId__": 65,
    "kind": "test",
    "name": "describe1",
    "testId": 1,
    "memberof": "test/functional/1member.test.js~describe0",
    "testDepth": 1,
    "static": true,
    "longname": "test/functional/1member.test.js~describe0.describe1",
    "access": null,
    "description": "🙂",
    "lineNumber": 10
  },
  {
    "__docId__": 66,
    "kind": "test",
    "name": "it2",
    "testId": 2,
    "memberof": "test/functional/1member.test.js~describe0.describe1",
    "testDepth": 2,
    "static": true,
    "longname": "test/functional/1member.test.js~describe0.describe1.it2",
    "access": null,
    "description": "constructor",
    "lineNumber": 13,
    "testTargets": [
      "WebGroup#constructor"
    ]
  },
  {
    "__docId__": 67,
    "kind": "test",
    "name": "describe3",
    "testId": 3,
    "memberof": "test/functional/1member.test.js~describe0.describe1",
    "testDepth": 2,
    "static": true,
    "longname": "test/functional/1member.test.js~describe0.describe1.describe3",
    "access": null,
    "description": "joining",
    "lineNumber": 65,
    "testTargets": [
      "WebGroup#join"
    ]
  },
  {
    "__docId__": 68,
    "kind": "test",
    "name": "it4",
    "testId": 4,
    "memberof": "test/functional/1member.test.js~describe0.describe1.describe3",
    "testDepth": 3,
    "static": true,
    "longname": "test/functional/1member.test.js~describe0.describe1.describe3.it4",
    "access": null,
    "description": "should change the Signaling state",
    "lineNumber": 85,
    "testTargets": [
      "WebGroup#onSignalingStateChange"
    ]
  },
  {
    "__docId__": 69,
    "kind": "test",
    "name": "it5",
    "testId": 5,
    "memberof": "test/functional/1member.test.js~describe0.describe1.describe3",
    "testDepth": 3,
    "static": true,
    "longname": "test/functional/1member.test.js~describe0.describe1.describe3.it5",
    "access": null,
    "description": "should change the WebGroup state",
    "lineNumber": 110,
    "testTargets": [
      "WebGroup#onStateChange"
    ]
  },
  {
    "__docId__": 70,
    "kind": "test",
    "name": "it6",
    "testId": 6,
    "memberof": "test/functional/1member.test.js~describe0.describe1.describe3",
    "testDepth": 3,
    "static": true,
    "longname": "test/functional/1member.test.js~describe0.describe1.describe3.it6",
    "access": null,
    "description": "should NOT be notified about new member",
    "lineNumber": 130,
    "testTargets": [
      "WebGroup#onMemberJoin"
    ]
  },
  {
    "__docId__": 71,
    "kind": "test",
    "name": "it7",
    "testId": 7,
    "memberof": "test/functional/1member.test.js~describe0.describe1.describe3",
    "testDepth": 3,
    "static": true,
    "longname": "test/functional/1member.test.js~describe0.describe1.describe3.it7",
    "access": null,
    "description": "should have the same members, WebGroup id, topology and NOT empty key once joined",
    "lineNumber": 144
  },
  {
    "__docId__": 72,
    "kind": "test",
    "name": "it8",
    "testId": 8,
    "memberof": "test/functional/1member.test.js~describe0.describe1.describe3",
    "testDepth": 3,
    "static": true,
    "longname": "test/functional/1member.test.js~describe0.describe1.describe3.it8",
    "access": null,
    "description": "should join with the specified key",
    "lineNumber": 170,
    "testTargets": [
      "WebGroup#join"
    ]
  },
  {
    "__docId__": 73,
    "kind": "test",
    "name": "describe9",
    "testId": 9,
    "memberof": "test/functional/1member.test.js~describe0.describe1",
    "testDepth": 2,
    "static": true,
    "longname": "test/functional/1member.test.js~describe0.describe1.describe9",
    "access": null,
    "description": "leaving",
    "lineNumber": 184
  },
  {
    "__docId__": 74,
    "kind": "test",
    "name": "it10",
    "testId": 10,
    "memberof": "test/functional/1member.test.js~describe0.describe1.describe9",
    "testDepth": 3,
    "static": true,
    "longname": "test/functional/1member.test.js~describe0.describe1.describe9.it10",
    "access": null,
    "description": "should have the same members, WebGroup id, topology and an empty key",
    "lineNumber": 197,
    "testTargets": [
      "WebGroup#leave"
    ]
  },
  {
    "__docId__": 75,
    "kind": "test",
    "name": "it11",
    "testId": 11,
    "memberof": "test/functional/1member.test.js~describe0.describe1.describe9",
    "testDepth": 3,
    "static": true,
    "longname": "test/functional/1member.test.js~describe0.describe1.describe9.it11",
    "access": null,
    "description": "should be NOT notified about left member",
    "lineNumber": 223,
    "testTargets": [
      "WebGroup#onMemberLeave"
    ]
  },
  {
    "__docId__": 76,
    "kind": "test",
    "name": "it12",
    "testId": 12,
    "memberof": "test/functional/1member.test.js~describe0.describe1.describe9",
    "testDepth": 3,
    "static": true,
    "longname": "test/functional/1member.test.js~describe0.describe1.describe9.it12",
    "access": null,
    "description": "should change the WebGroup state",
    "lineNumber": 238,
    "testTargets": [
      "WebGroup#onStateChange"
    ]
  },
  {
    "__docId__": 77,
    "kind": "test",
    "name": "it13",
    "testId": 13,
    "memberof": "test/functional/1member.test.js~describe0.describe1.describe9",
    "testDepth": 3,
    "static": true,
    "longname": "test/functional/1member.test.js~describe0.describe1.describe9.it13",
    "access": null,
    "description": "should change the Signaling state",
    "lineNumber": 258,
    "testTargets": [
      "WebGroup#onSignalingStateChange"
    ]
  },
  {
    "__docId__": 78,
    "kind": "testFile",
    "name": "test/functional/2members.test.js",
    "content": "/// <reference types='jasmine' />\n/* tslint:disable:one-variable-per-declaration */\nimport { SignalingState, WebGroup, WebGroupState } from '../../src/index.browser';\nimport { areTheSame, BOT_URL, cleanWebGroup, getBotData, Queue, SIGNALING_URL, wait, waitBotJoin, } from '../util/helper';\nconst WebGroupOptions = {\n    signalingServer: SIGNALING_URL,\n    autoRejoin: false,\n};\n/** @test {WebGroup} */\ndescribe('2 members', () => {\n    describe('🙂 🙂', () => {\n        let wg1, wg2;\n        /** @test {WebGroup#join} */\n        describe('joining', () => {\n            beforeEach((done) => {\n                wg1 = new WebGroup(WebGroupOptions);\n                wg2 = new WebGroup(WebGroupOptions);\n                wg1.onStateChange = (state) => {\n                    if (state === WebGroupState.JOINED) {\n                        cleanWebGroup(wg1, wg2);\n                        done();\n                    }\n                };\n                wg1.join();\n            });\n            afterEach((done) => {\n                cleanWebGroup(wg1, wg2);\n                const queue = new Queue(2, () => {\n                    cleanWebGroup(wg1, wg2);\n                    done();\n                });\n                if (wg1.state !== WebGroupState.LEFT) {\n                    wg1.onStateChange = (state) => {\n                        if (state === WebGroupState.LEFT) {\n                            queue.done();\n                        }\n                    };\n                    wg1.leave();\n                }\n                else {\n                    queue.done();\n                }\n                if (wg2.state !== WebGroupState.LEFT) {\n                    wg2.onStateChange = (state) => {\n                        if (state === WebGroupState.LEFT) {\n                            queue.done();\n                        }\n                    };\n                    wg2.leave();\n                }\n                else {\n                    queue.done();\n                }\n            });\n            /** @test {WebGroup#onSignalingStateChange} */\n            it('should change the Signaling state', (done) => {\n                let called1 = 0, called2 = 0;\n                const states = [];\n                const expectedStates = [\n                    SignalingState.CONNECTING,\n                    SignalingState.OPEN,\n                    SignalingState.CHECKING,\n                    SignalingState.CHECKED,\n                    SignalingState.CHECKING,\n                    SignalingState.CHECKED,\n                ];\n                // Code for peer 1\n                wg1.onSignalingStateChange = () => called1++;\n                // Code for peer 2\n                wg2.onSignalingStateChange = (state) => {\n                    states.push(state);\n                    called2++;\n                    if (called2 === expectedStates.length) {\n                        wait(1000).then(() => {\n                            expect(called1).toEqual(0);\n                            expect(called2).toEqual(expectedStates.length);\n                            expect(states).toEqual(expectedStates);\n                            expect(wg2.signalingState).toEqual(SignalingState.CHECKED);\n                            done();\n                        });\n                    }\n                };\n                // Start joining\n                wg2.join(wg1.key);\n            });\n            /** @test {WebGroup#onStateChange} */\n            it('should change the WebGroup state', (done) => {\n                let called1 = 0, called2 = 0;\n                const states = [];\n                const expectedStates = [WebGroupState.JOINING, WebGroupState.JOINED];\n                // Code for peer 1\n                wg1.onStateChange = () => called1++;\n                // Code for peer 2\n                wg2.onStateChange = (state) => {\n                    states.push(state);\n                    called2++;\n                    if (called2 === expectedStates.length) {\n                        wait(1000).then(() => {\n                            expect(called1).toEqual(0);\n                            expect(called2).toEqual(2);\n                            expect(states).toEqual(expectedStates);\n                            expect(wg2.state).toEqual(WebGroupState.JOINED);\n                            done();\n                        });\n                    }\n                };\n                // Start joining\n                wg2.join(wg1.key);\n            });\n            /** @test {WebGroup#onMemberJoin} */\n            it('should be notified about new member', (done) => {\n                let called1 = 0, called2 = 0;\n                const queue = new Queue(2, () => {\n                    wait(1000).then(() => {\n                        expect(called1).toEqual(1);\n                        expect(called2).toEqual(1);\n                        done();\n                    });\n                });\n                // Code for peer 1\n                wg1.onMemberJoin = (id) => {\n                    expect(id).toEqual(wg2.myId);\n                    called1++;\n                    queue.done();\n                };\n                // Code for peer 2\n                wg2.onMemberJoin = (id) => {\n                    expect(id).toEqual(wg1.myId);\n                    called2++;\n                    queue.done();\n                };\n                // Start joining\n                wg2.join(wg1.key);\n            });\n            it('should have the same members, key, WebGroup id, topology once joined', (done) => {\n                const queue = new Queue(2, () => {\n                    wait(1000).then(() => {\n                        expect(areTheSame(wg2.members, wg1.members)).toBeTruthy();\n                        expect(wg2.id).toEqual(wg1.id);\n                        expect(wg2.key).toEqual(wg1.key);\n                        expect(wg2.topology).toEqual(wg1.topology);\n                        done();\n                    });\n                });\n                // Code for peer 1\n                wg1.onMemberJoin = () => {\n                    expect(wg1.members.length).toEqual(2);\n                    expect(wg1.members.includes(wg1.myId)).toBeTruthy();\n                    expect(wg1.members.includes(wg2.myId)).toBeTruthy();\n                    queue.done();\n                };\n                // Code for peer 2\n                wg2.onStateChange = (state) => {\n                    if (state === WebGroupState.JOINED) {\n                        expect(wg2.members.length).toEqual(2);\n                        expect(wg2.members.includes(wg1.myId)).toBeTruthy();\n                        expect(wg2.members.includes(wg2.myId)).toBeTruthy();\n                        expect(wg2.id).toEqual(wg1.id);\n                        expect(wg2.key).toEqual(wg1.key);\n                        expect(wg2.topology).toEqual(wg1.topology);\n                        queue.done();\n                    }\n                };\n                // Start joining\n                wg2.join(wg1.key);\n            });\n            /** @test {WebGroup#join} */\n            it('should join with the specified key', (done) => {\n                const queue = new Queue(3, () => {\n                    wg.leave();\n                    done();\n                });\n                const key = 'ArtIsLongLifeIsShort';\n                const wg = new WebGroup(WebGroupOptions);\n                // Code for peer 1\n                wg.onStateChange = (state) => {\n                    if (state === WebGroupState.JOINED) {\n                        wg2.join(key);\n                    }\n                };\n                wg.onMemberJoin = () => queue.done();\n                // Code for peer 2\n                wg2.onStateChange = (state) => {\n                    if (state === WebGroupState.JOINED) {\n                        expect(wg.key).toEqual(key);\n                        expect(wg2.key).toEqual(key);\n                        queue.done();\n                    }\n                };\n                wg2.onMemberJoin = () => queue.done();\n                // Start joining\n                wg.join(key);\n            });\n        });\n        describe('should send/receive', () => {\n            let called1, called2;\n            beforeEach((done) => {\n                called1 = 0;\n                called2 = 0;\n                const queue = new Queue(3, () => {\n                    cleanWebGroup(wg1, wg2);\n                    done();\n                });\n                wg1 = new WebGroup(WebGroupOptions);\n                wg2 = new WebGroup(WebGroupOptions);\n                wg1.onStateChange = (state) => {\n                    if (state === WebGroupState.JOINED) {\n                        wg2.join(wg1.key);\n                    }\n                };\n                wg1.onMemberJoin = () => queue.done();\n                wg2.onStateChange = (state) => {\n                    if (state === WebGroupState.JOINED) {\n                        queue.done();\n                    }\n                };\n                wg2.onMemberJoin = () => queue.done();\n                wg1.join();\n            });\n            afterEach((done) => {\n                cleanWebGroup(wg1, wg2);\n                const queue = new Queue(2, () => {\n                    cleanWebGroup(wg1, wg2);\n                    done();\n                });\n                if (wg1.state !== WebGroupState.LEFT) {\n                    wg1.onStateChange = (state) => {\n                        if (state === WebGroupState.LEFT) {\n                            queue.done();\n                        }\n                    };\n                    wg1.leave();\n                }\n                else {\n                    queue.done();\n                }\n                if (wg2.state !== WebGroupState.LEFT) {\n                    wg2.onStateChange = (state) => {\n                        if (state === WebGroupState.LEFT) {\n                            queue.done();\n                        }\n                    };\n                    wg2.leave();\n                }\n                else {\n                    queue.done();\n                }\n            });\n            /** @test {WebGroup#send} */\n            it('broadcast String', (done) => {\n                const msg1 = 'Art is long, life is short';\n                const msg2 = 'Do or do not, there is no try';\n                // Code for peer 1\n                wg1.onMessage = (id, msg) => {\n                    expect(id).toEqual(wg2.myId);\n                    expect(msg).toEqual(msg2);\n                    wg1.send(msg1);\n                    called1++;\n                };\n                // Code for peer 2\n                wg2.onMessage = (id, msg) => {\n                    expect(id).toEqual(wg1.myId);\n                    expect(msg).toEqual(msg1);\n                    called2++;\n                    wait(1000).then(() => {\n                        expect(called1).toEqual(1);\n                        expect(called2).toEqual(1);\n                        done();\n                    });\n                };\n                // Start sending message\n                wg2.send(msg2);\n            });\n            /** @test {WebGroup#send} */\n            it('broadcast ArrayBuffer', (done) => {\n                const msg1 = new Uint8Array([42, 347, 248247, 583, 10, 8, 9623]);\n                const msg2 = new Uint8Array([845, 4, 798240, 3290, 553, 1, 398539857, 84]);\n                // Code for peer 1\n                wg1.onMessage = (id, msg) => {\n                    expect(id).toEqual(wg2.myId);\n                    expect(msg instanceof Uint8Array);\n                    expect(msg).toEqual(msg2);\n                    wg1.send(msg1);\n                    called1++;\n                };\n                // Code for peer 2\n                wg2.onMessage = (id, msg) => {\n                    expect(id).toEqual(wg1.myId);\n                    expect(msg instanceof Uint8Array);\n                    expect(msg).toEqual(msg1);\n                    called2++;\n                    wait(1000).then(() => {\n                        expect(called1).toEqual(1);\n                        expect(called2).toEqual(1);\n                        done();\n                    });\n                };\n                // Start sending message\n                wg2.send(msg2);\n            });\n            /** @test {WebGroup#sendTo} */\n            it('private String', (done) => {\n                const msg1 = 'Art is long, life is short';\n                const msg2 = 'Do or do not, there is no try';\n                // Code for peer 1\n                wg1.onMessage = (id, msg) => {\n                    expect(id).toEqual(wg2.myId);\n                    expect(msg).toEqual(msg2);\n                    wg1.sendTo(wg2.myId, msg1);\n                    called1++;\n                };\n                // Code for peer 2\n                wg2.onMessage = (id, msg) => {\n                    expect(id).toEqual(wg1.myId);\n                    expect(msg).toEqual(msg1);\n                    called2++;\n                    wait(1000).then(() => {\n                        expect(called1).toEqual(1);\n                        expect(called2).toEqual(1);\n                        done();\n                    });\n                };\n                // Start sending message\n                wg2.sendTo(wg1.myId, msg2);\n            });\n            /** @test {WebGroup#sendTo} */\n            it('private ArrayBuffer', (done) => {\n                const msg1 = new Uint8Array([42, 347, 248247, 583, 10, 8, 9623]);\n                const msg2 = new Uint8Array([845, 4, 798240, 3290, 553, 1, 398539857, 84]);\n                // Code for peer 1\n                wg1.onMessage = (id, msg) => {\n                    expect(id).toEqual(wg2.myId);\n                    expect(msg instanceof Uint8Array);\n                    expect(msg).toEqual(msg2);\n                    wg1.sendTo(wg2.myId, msg1);\n                    called1++;\n                };\n                // Code for peer 2\n                wg2.onMessage = (id, msg) => {\n                    expect(id).toEqual(wg1.myId);\n                    expect(msg instanceof Uint8Array);\n                    expect(msg).toEqual(msg1);\n                    called2++;\n                    wait(1000).then(() => {\n                        expect(called1).toEqual(1);\n                        expect(called2).toEqual(1);\n                        done();\n                    });\n                };\n                // Start sending message\n                wg2.sendTo(wg1.myId, msg2);\n            });\n        });\n        describe('leaving', () => {\n            let called1, called2;\n            beforeEach((done) => {\n                called1 = 0;\n                called2 = 0;\n                const queue = new Queue(3, () => {\n                    cleanWebGroup(wg1, wg2);\n                    done();\n                });\n                wg1 = new WebGroup(WebGroupOptions);\n                wg2 = new WebGroup(WebGroupOptions);\n                wg1.onStateChange = (state) => {\n                    if (state === WebGroupState.JOINED) {\n                        wg2.join(wg1.key);\n                    }\n                };\n                wg1.onMemberJoin = () => queue.done();\n                wg2.onStateChange = (state) => {\n                    if (state === WebGroupState.JOINED) {\n                        queue.done();\n                    }\n                };\n                wg2.onMemberJoin = () => queue.done();\n                wg1.join();\n            });\n            afterEach((done) => {\n                cleanWebGroup(wg1, wg2);\n                const queue = new Queue(2, () => {\n                    cleanWebGroup(wg1, wg2);\n                    wait(1000).then(done);\n                });\n                if (wg1.state !== WebGroupState.LEFT) {\n                    wg1.onStateChange = (state) => {\n                        if (state === WebGroupState.LEFT) {\n                            queue.done();\n                        }\n                    };\n                    wg1.leave();\n                }\n                else {\n                    queue.done();\n                }\n                if (wg2.state !== WebGroupState.LEFT) {\n                    wg2.onStateChange = (state) => {\n                        if (state === WebGroupState.LEFT) {\n                            queue.done();\n                        }\n                    };\n                    wg2.leave();\n                }\n                else {\n                    queue.done();\n                }\n            });\n            /** @test {WebGroup#leave} */\n            it('should have no members & an empty key', (done) => {\n                const queue = new Queue(2, () => {\n                    wait(1000).then(() => {\n                        expect(wg1.members.length).toEqual(1);\n                        expect(wg1.members.includes(wg1.myId)).toBeTruthy();\n                        expect(wg2.members.length).toEqual(1);\n                        expect(wg2.members.includes(wg2.myId)).toBeTruthy();\n                        expect(wg2.key).toEqual('');\n                        expect(called2).toEqual(1);\n                        expect(wg2.key).toEqual('');\n                        done();\n                    });\n                });\n                // Code for peer 1\n                wg1.onMemberLeave = () => {\n                    expect(wg1.members.length).toEqual(1);\n                    expect(wg1.members.includes(wg1.myId)).toBeTruthy();\n                    queue.done();\n                };\n                // Code for peer 2\n                wg2.onStateChange = (state) => {\n                    if (state === WebGroupState.LEFT) {\n                        called2++;\n                        expect(wg2.members.length).toEqual(1);\n                        expect(wg2.members.includes(wg2.myId)).toBeTruthy();\n                        expect(wg2.key).toEqual('');\n                        queue.done();\n                    }\n                };\n                // Start leaving\n                wg2.leave();\n            }, 12000);\n            /** @test {WebGroup#onMemberLeave} */\n            it('should be notified about left member', (done) => {\n                const queue = new Queue(2, () => {\n                    wait(1000).then(() => {\n                        expect(called1).toEqual(1);\n                        expect(called2).toEqual(1);\n                        done();\n                    });\n                });\n                // Code for peer 1\n                wg1.onMemberLeave = (id) => {\n                    expect(id).toEqual(wg2.myId);\n                    called1++;\n                    queue.done();\n                };\n                // Code for peer 2\n                wg2.onMemberLeave = (id) => {\n                    expect(id).toEqual(wg1.myId);\n                    called2++;\n                    queue.done();\n                };\n                // Start leaving\n                wg2.leave();\n            }, 12000);\n            /** @test {WebGroup#onStateChange} */\n            it('should change the WebGroup state', (done) => {\n                const states = [];\n                const expectedStates = [WebGroupState.LEAVING, WebGroupState.LEFT];\n                // Code for peer 2\n                wg2.onStateChange = (state) => {\n                    states.push(state);\n                    called2++;\n                    if (state === WebGroupState.LEFT) {\n                        wait(1000).then(() => {\n                            expect(called2).toEqual(2);\n                            expect(states).toEqual(expectedStates);\n                            done();\n                        });\n                    }\n                };\n                // Start leaving\n                wg2.leave();\n            }, 12000);\n            /** @test {WebGroup#onSignalingStateChange} */\n            it('should change the Signaling state', (done) => {\n                const states = [];\n                const expectedStates = [SignalingState.CLOSING, SignalingState.CLOSED];\n                // Code for peer 2\n                wg2.onSignalingStateChange = (state) => {\n                    states.push(state);\n                    called2++;\n                    if (state === SignalingState.CLOSED) {\n                        wait(1000).then(() => {\n                            expect(called2).toEqual(2);\n                            expect(states).toEqual(expectedStates);\n                            done();\n                        });\n                    }\n                };\n                // Start leaving\n                wg2.leave();\n            }, 12000);\n        });\n    });\n    describe('🙂 🤖', () => {\n        let wg1;\n        /** @test {WebGroup#invite} */\n        describe('inviting', () => {\n            beforeEach(() => (wg1 = new WebGroup(WebGroupOptions)));\n            afterEach((done) => {\n                cleanWebGroup(wg1);\n                if (wg1.state !== WebGroupState.LEFT) {\n                    wg1.onStateChange = (state) => {\n                        if (state === WebGroupState.LEFT) {\n                            cleanWebGroup(wg1);\n                            done();\n                        }\n                    };\n                    wg1.leave();\n                }\n                else {\n                    done();\n                }\n            });\n            /** @test {WebGroup#onSignalingStateChange} */\n            it('should not change the Signaling state', (done) => {\n                // Code for peer 1\n                wg1.onStateChange = (state) => {\n                    if (state === WebGroupState.JOINED) {\n                        // Start inviting\n                        wg1.invite(BOT_URL);\n                        // Check bot data\n                        waitBotJoin(wg1.id)\n                            .then(() => wait(1000))\n                            .then(() => getBotData(wg1.id))\n                            .then((data) => {\n                            expect(data.onSignalingStateCalled).toEqual(0);\n                            expect(data.signalingState).toEqual(SignalingState.CLOSED);\n                            done();\n                        });\n                    }\n                };\n                // Start joining\n                wg1.join();\n            });\n            /** @test {WebGroup#onStateChange} */\n            it('should change the WebGroup state', (done) => {\n                // Code for peer 1\n                wg1.onStateChange = (state) => {\n                    if (state === WebGroupState.JOINED) {\n                        // Start inviting\n                        wg1.invite(BOT_URL);\n                        // Check bot data\n                        waitBotJoin(wg1.id)\n                            .then(() => wait(1000))\n                            .then(() => getBotData(wg1.id))\n                            .then((data) => {\n                            expect(data.state).toEqual(WebGroupState.JOINED);\n                            done();\n                        })\n                            .catch(fail);\n                    }\n                };\n                // Start joining\n                wg1.join();\n            });\n            /** @test {WebGroup#onMemberJoin} */\n            it('should be notified about new member', (done) => {\n                let called1 = 0;\n                // Code for peer 1\n                wg1.onStateChange = (state) => {\n                    if (state === WebGroupState.JOINED) {\n                        // Start inviting\n                        wg1.invite(BOT_URL);\n                    }\n                };\n                wg1.onMemberJoin = (id) => {\n                    called1++;\n                    // Check bot data\n                    waitBotJoin(wg1.id)\n                        .then(() => wait(1000))\n                        .then(() => getBotData(wg1.id))\n                        .then((bot) => {\n                        expect(id).toEqual(bot.myId);\n                        expect(bot.onMemberJoinCalled).toEqual(1);\n                        expect(bot.joinedMembers.length).toEqual(1);\n                        expect(bot.joinedMembers[0]).toEqual(wg1.myId);\n                        expect(called1).toEqual(1);\n                        done();\n                    })\n                        .catch(fail);\n                };\n                // Start joining\n                wg1.join();\n            });\n            it('should have the same members, WebGroup id, topology once joined', (done) => {\n                // Code for peer 1\n                wg1.onStateChange = (state) => {\n                    if (state === WebGroupState.JOINED) {\n                        // Start inviting\n                        wg1.invite(BOT_URL);\n                    }\n                };\n                wg1.onMemberJoin = () => {\n                    // Check bot data\n                    waitBotJoin(wg1.id)\n                        .then(() => wait(1000))\n                        .then(() => getBotData(wg1.id))\n                        .then((bot) => {\n                        expect(areTheSame(bot.members, wg1.members)).toBeTruthy();\n                        expect(bot.key).toEqual('');\n                        expect(bot.topology).toEqual(wg1.topology);\n                        expect(bot.id).toEqual(wg1.id);\n                        done();\n                    })\n                        .catch(fail);\n                };\n                // Start joining\n                wg1.join();\n            });\n        });\n        describe('should send/receive', () => {\n            let called1;\n            beforeEach((done) => {\n                called1 = 0;\n                const queue = new Queue(2, () => {\n                    cleanWebGroup(wg1);\n                    done();\n                });\n                wg1 = new WebGroup(WebGroupOptions);\n                wg1.onMemberJoin = () => queue.done();\n                wg1.onStateChange = (state) => {\n                    if (state === WebGroupState.JOINED) {\n                        wg1.invite(BOT_URL);\n                        waitBotJoin(wg1.id).then(() => queue.done());\n                    }\n                };\n                wg1.join();\n            });\n            afterEach((done) => {\n                cleanWebGroup(wg1);\n                if (wg1.state !== WebGroupState.LEFT) {\n                    wg1.onStateChange = (state) => {\n                        if (state === WebGroupState.LEFT) {\n                            cleanWebGroup(wg1);\n                            done();\n                        }\n                    };\n                    wg1.leave();\n                }\n                else {\n                    cleanWebGroup(wg1);\n                    done();\n                }\n            });\n            /** @test {WebGroup#send} */\n            it('broadcast String', (done) => {\n                const msg1 = 'sendArt is long, life is short';\n                const msgBot = 'bot: ' + msg1;\n                // Code for peer 1\n                wg1.onMessage = (id, msg) => {\n                    called1++;\n                    expect(msg).toEqual(msgBot);\n                    // Check bot data\n                    wait(1000)\n                        .then(() => getBotData(wg1.id))\n                        .then((bot) => {\n                        expect(called1).toEqual(1);\n                        expect(id).toEqual(bot.myId);\n                        expect(bot.onMessageToBeCalled).toEqual(1);\n                        expect(bot.messages[0].msg).toEqual(msg1);\n                        expect(bot.messages[0].id).toEqual(wg1.myId);\n                        done();\n                    })\n                        .catch(fail);\n                };\n                // Start sending message\n                wg1.send(msg1);\n            });\n            /** @test {WebGroup#send} */\n            it('broadcast ArrayBuffer', (done) => {\n                const msg1 = new Uint8Array([10, 34, 248, 157, 10, 8, 220]);\n                const msgBot = new Uint8Array([42, 34, 248, 157, 10, 8, 220]);\n                // Code for peer 1\n                wg1.onMessage = (id, msg) => {\n                    called1++;\n                    expect(msg).toEqual(msgBot);\n                    // Check bot data\n                    wait(1000)\n                        .then(() => getBotData(wg1.id))\n                        .then((bot) => {\n                        expect(called1).toEqual(1);\n                        expect(id).toEqual(bot.myId);\n                        expect(bot.onMessageToBeCalled).toEqual(1);\n                        expect(bot.messages[0].msg).toEqual(Array.from(msg1));\n                        expect(bot.messages[0].id).toEqual(wg1.myId);\n                        done();\n                    })\n                        .catch(fail);\n                };\n                // Start sending message\n                wg1.send(msg1);\n            });\n            /** @test {WebGroup#sendTo} */\n            it('private String', (done) => {\n                const msg1 = 'Art is long, life is short';\n                const msgBot = 'bot: ' + msg1;\n                // Code for peer 1\n                wg1.onMessage = (id, msg) => {\n                    called1++;\n                    expect(msg).toEqual(msgBot);\n                    // Check bot data\n                    wait(1000)\n                        .then(() => getBotData(wg1.id))\n                        .then((bot) => {\n                        expect(called1).toEqual(1);\n                        expect(id).toEqual(bot.myId);\n                        expect(bot.onMessageToBeCalled).toEqual(1);\n                        expect(bot.messages[0].msg).toEqual(msg1);\n                        expect(bot.messages[0].id).toEqual(wg1.myId);\n                        done();\n                    })\n                        .catch(fail);\n                };\n                // Start sending message\n                wg1.sendTo(wg1.members[1], msg1);\n            });\n            /** @test {WebGroup#sendTo} */\n            it('private ArrayBuffer', (done) => {\n                const msg1 = new Uint8Array([45, 34, 248, 157, 10, 8, 220]);\n                const msgBot = new Uint8Array([42, 34, 248, 157, 10, 8, 220]);\n                // Code for peer 1\n                wg1.onMessage = (id, msg) => {\n                    called1++;\n                    expect(msg).toEqual(msgBot);\n                    // Check bot data\n                    wait(1000)\n                        .then(() => getBotData(wg1.id))\n                        .then((bot) => {\n                        expect(called1).toEqual(1);\n                        expect(id).toEqual(bot.myId);\n                        expect(bot.onMessageToBeCalled).toEqual(1);\n                        expect(bot.messages[0].msg).toEqual(Array.from(msg1));\n                        expect(bot.messages[0].id).toEqual(wg1.myId);\n                        done();\n                    })\n                        .catch(fail);\n                };\n                // Start sending message\n                wg1.sendTo(wg1.members[1], msg1);\n            });\n        });\n        // TODO: finish these tests\n        xdescribe('leaving', () => { });\n    });\n});\n",
    "static": true,
    "longname": "/home/philippe/workspace/netflux/docs/jsFromTs/test/functional/2members.test.js",
    "access": null,
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 79,
    "kind": "test",
    "name": "describe14",
    "testId": 14,
    "memberof": "test/functional/2members.test.js",
    "testDepth": 0,
    "static": true,
    "longname": "test/functional/2members.test.js~describe14",
    "access": null,
    "description": "2 members",
    "lineNumber": 10,
    "testTargets": [
      "WebGroup"
    ]
  },
  {
    "__docId__": 80,
    "kind": "test",
    "name": "describe15",
    "testId": 15,
    "memberof": "test/functional/2members.test.js~describe14",
    "testDepth": 1,
    "static": true,
    "longname": "test/functional/2members.test.js~describe14.describe15",
    "access": null,
    "description": "🙂 🙂",
    "lineNumber": 11
  },
  {
    "__docId__": 81,
    "kind": "test",
    "name": "describe16",
    "testId": 16,
    "memberof": "test/functional/2members.test.js~describe14.describe15",
    "testDepth": 2,
    "static": true,
    "longname": "test/functional/2members.test.js~describe14.describe15.describe16",
    "access": null,
    "description": "joining",
    "lineNumber": 14,
    "testTargets": [
      "WebGroup#join"
    ]
  },
  {
    "__docId__": 82,
    "kind": "test",
    "name": "it17",
    "testId": 17,
    "memberof": "test/functional/2members.test.js~describe14.describe15.describe16",
    "testDepth": 3,
    "static": true,
    "longname": "test/functional/2members.test.js~describe14.describe15.describe16.it17",
    "access": null,
    "description": "should change the Signaling state",
    "lineNumber": 56,
    "testTargets": [
      "WebGroup#onSignalingStateChange"
    ]
  },
  {
    "__docId__": 83,
    "kind": "test",
    "name": "it18",
    "testId": 18,
    "memberof": "test/functional/2members.test.js~describe14.describe15.describe16",
    "testDepth": 3,
    "static": true,
    "longname": "test/functional/2members.test.js~describe14.describe15.describe16.it18",
    "access": null,
    "description": "should change the WebGroup state",
    "lineNumber": 87,
    "testTargets": [
      "WebGroup#onStateChange"
    ]
  },
  {
    "__docId__": 84,
    "kind": "test",
    "name": "it19",
    "testId": 19,
    "memberof": "test/functional/2members.test.js~describe14.describe15.describe16",
    "testDepth": 3,
    "static": true,
    "longname": "test/functional/2members.test.js~describe14.describe15.describe16.it19",
    "access": null,
    "description": "should be notified about new member",
    "lineNumber": 111,
    "testTargets": [
      "WebGroup#onMemberJoin"
    ]
  },
  {
    "__docId__": 85,
    "kind": "test",
    "name": "it20",
    "testId": 20,
    "memberof": "test/functional/2members.test.js~describe14.describe15.describe16",
    "testDepth": 3,
    "static": true,
    "longname": "test/functional/2members.test.js~describe14.describe15.describe16.it20",
    "access": null,
    "description": "should have the same members, key, WebGroup id, topology once joined",
    "lineNumber": 135
  },
  {
    "__docId__": 86,
    "kind": "test",
    "name": "it21",
    "testId": 21,
    "memberof": "test/functional/2members.test.js~describe14.describe15.describe16",
    "testDepth": 3,
    "static": true,
    "longname": "test/functional/2members.test.js~describe14.describe15.describe16.it21",
    "access": null,
    "description": "should join with the specified key",
    "lineNumber": 168,
    "testTargets": [
      "WebGroup#join"
    ]
  },
  {
    "__docId__": 87,
    "kind": "test",
    "name": "describe22",
    "testId": 22,
    "memberof": "test/functional/2members.test.js~describe14.describe15",
    "testDepth": 2,
    "static": true,
    "longname": "test/functional/2members.test.js~describe14.describe15.describe22",
    "access": null,
    "description": "should send/receive",
    "lineNumber": 195
  },
  {
    "__docId__": 88,
    "kind": "test",
    "name": "it23",
    "testId": 23,
    "memberof": "test/functional/2members.test.js~describe14.describe15.describe22",
    "testDepth": 3,
    "static": true,
    "longname": "test/functional/2members.test.js~describe14.describe15.describe22.it23",
    "access": null,
    "description": "broadcast String",
    "lineNumber": 250,
    "testTargets": [
      "WebGroup#send"
    ]
  },
  {
    "__docId__": 89,
    "kind": "test",
    "name": "it24",
    "testId": 24,
    "memberof": "test/functional/2members.test.js~describe14.describe15.describe22",
    "testDepth": 3,
    "static": true,
    "longname": "test/functional/2members.test.js~describe14.describe15.describe22.it24",
    "access": null,
    "description": "broadcast ArrayBuffer",
    "lineNumber": 275,
    "testTargets": [
      "WebGroup#send"
    ]
  },
  {
    "__docId__": 90,
    "kind": "test",
    "name": "it25",
    "testId": 25,
    "memberof": "test/functional/2members.test.js~describe14.describe15.describe22",
    "testDepth": 3,
    "static": true,
    "longname": "test/functional/2members.test.js~describe14.describe15.describe22.it25",
    "access": null,
    "description": "private String",
    "lineNumber": 302,
    "testTargets": [
      "WebGroup#sendTo"
    ]
  },
  {
    "__docId__": 91,
    "kind": "test",
    "name": "it26",
    "testId": 26,
    "memberof": "test/functional/2members.test.js~describe14.describe15.describe22",
    "testDepth": 3,
    "static": true,
    "longname": "test/functional/2members.test.js~describe14.describe15.describe22.it26",
    "access": null,
    "description": "private ArrayBuffer",
    "lineNumber": 327,
    "testTargets": [
      "WebGroup#sendTo"
    ]
  },
  {
    "__docId__": 92,
    "kind": "test",
    "name": "describe27",
    "testId": 27,
    "memberof": "test/functional/2members.test.js~describe14.describe15",
    "testDepth": 2,
    "static": true,
    "longname": "test/functional/2members.test.js~describe14.describe15.describe27",
    "access": null,
    "description": "leaving",
    "lineNumber": 354
  },
  {
    "__docId__": 93,
    "kind": "test",
    "name": "it28",
    "testId": 28,
    "memberof": "test/functional/2members.test.js~describe14.describe15.describe27",
    "testDepth": 3,
    "static": true,
    "longname": "test/functional/2members.test.js~describe14.describe15.describe27.it28",
    "access": null,
    "description": "should have no members & an empty key",
    "lineNumber": 409,
    "testTargets": [
      "WebGroup#leave"
    ]
  },
  {
    "__docId__": 94,
    "kind": "test",
    "name": "it29",
    "testId": 29,
    "memberof": "test/functional/2members.test.js~describe14.describe15.describe27",
    "testDepth": 3,
    "static": true,
    "longname": "test/functional/2members.test.js~describe14.describe15.describe27.it29",
    "access": null,
    "description": "should be notified about left member",
    "lineNumber": 442,
    "testTargets": [
      "WebGroup#onMemberLeave"
    ]
  },
  {
    "__docId__": 95,
    "kind": "test",
    "name": "it30",
    "testId": 30,
    "memberof": "test/functional/2members.test.js~describe14.describe15.describe27",
    "testDepth": 3,
    "static": true,
    "longname": "test/functional/2members.test.js~describe14.describe15.describe27.it30",
    "access": null,
    "description": "should change the WebGroup state",
    "lineNumber": 466,
    "testTargets": [
      "WebGroup#onStateChange"
    ]
  },
  {
    "__docId__": 96,
    "kind": "test",
    "name": "it31",
    "testId": 31,
    "memberof": "test/functional/2members.test.js~describe14.describe15.describe27",
    "testDepth": 3,
    "static": true,
    "longname": "test/functional/2members.test.js~describe14.describe15.describe27.it31",
    "access": null,
    "description": "should change the Signaling state",
    "lineNumber": 485,
    "testTargets": [
      "WebGroup#onSignalingStateChange"
    ]
  },
  {
    "__docId__": 97,
    "kind": "test",
    "name": "describe32",
    "testId": 32,
    "memberof": "test/functional/2members.test.js~describe14",
    "testDepth": 1,
    "static": true,
    "longname": "test/functional/2members.test.js~describe14.describe32",
    "access": null,
    "description": "🙂 🤖",
    "lineNumber": 505
  },
  {
    "__docId__": 98,
    "kind": "test",
    "name": "describe33",
    "testId": 33,
    "memberof": "test/functional/2members.test.js~describe14.describe32",
    "testDepth": 2,
    "static": true,
    "longname": "test/functional/2members.test.js~describe14.describe32.describe33",
    "access": null,
    "description": "inviting",
    "lineNumber": 508,
    "testTargets": [
      "WebGroup#invite"
    ]
  },
  {
    "__docId__": 99,
    "kind": "test",
    "name": "it34",
    "testId": 34,
    "memberof": "test/functional/2members.test.js~describe14.describe32.describe33",
    "testDepth": 3,
    "static": true,
    "longname": "test/functional/2members.test.js~describe14.describe32.describe33.it34",
    "access": null,
    "description": "should not change the Signaling state",
    "lineNumber": 526,
    "testTargets": [
      "WebGroup#onSignalingStateChange"
    ]
  },
  {
    "__docId__": 100,
    "kind": "test",
    "name": "it35",
    "testId": 35,
    "memberof": "test/functional/2members.test.js~describe14.describe32.describe33",
    "testDepth": 3,
    "static": true,
    "longname": "test/functional/2members.test.js~describe14.describe32.describe33.it35",
    "access": null,
    "description": "should change the WebGroup state",
    "lineNumber": 547,
    "testTargets": [
      "WebGroup#onStateChange"
    ]
  },
  {
    "__docId__": 101,
    "kind": "test",
    "name": "it36",
    "testId": 36,
    "memberof": "test/functional/2members.test.js~describe14.describe32.describe33",
    "testDepth": 3,
    "static": true,
    "longname": "test/functional/2members.test.js~describe14.describe32.describe33.it36",
    "access": null,
    "description": "should be notified about new member",
    "lineNumber": 568,
    "testTargets": [
      "WebGroup#onMemberJoin"
    ]
  },
  {
    "__docId__": 102,
    "kind": "test",
    "name": "it37",
    "testId": 37,
    "memberof": "test/functional/2members.test.js~describe14.describe32.describe33",
    "testDepth": 3,
    "static": true,
    "longname": "test/functional/2members.test.js~describe14.describe32.describe33.it37",
    "access": null,
    "description": "should have the same members, WebGroup id, topology once joined",
    "lineNumber": 596
  },
  {
    "__docId__": 103,
    "kind": "test",
    "name": "describe38",
    "testId": 38,
    "memberof": "test/functional/2members.test.js~describe14.describe32",
    "testDepth": 2,
    "static": true,
    "longname": "test/functional/2members.test.js~describe14.describe32.describe38",
    "access": null,
    "description": "should send/receive",
    "lineNumber": 622
  },
  {
    "__docId__": 104,
    "kind": "test",
    "name": "it39",
    "testId": 39,
    "memberof": "test/functional/2members.test.js~describe14.describe32.describe38",
    "testDepth": 3,
    "static": true,
    "longname": "test/functional/2members.test.js~describe14.describe32.describe38.it39",
    "access": null,
    "description": "broadcast String",
    "lineNumber": 657,
    "testTargets": [
      "WebGroup#send"
    ]
  },
  {
    "__docId__": 105,
    "kind": "test",
    "name": "it40",
    "testId": 40,
    "memberof": "test/functional/2members.test.js~describe14.describe32.describe38",
    "testDepth": 3,
    "static": true,
    "longname": "test/functional/2members.test.js~describe14.describe32.describe38.it40",
    "access": null,
    "description": "broadcast ArrayBuffer",
    "lineNumber": 681,
    "testTargets": [
      "WebGroup#send"
    ]
  },
  {
    "__docId__": 106,
    "kind": "test",
    "name": "it41",
    "testId": 41,
    "memberof": "test/functional/2members.test.js~describe14.describe32.describe38",
    "testDepth": 3,
    "static": true,
    "longname": "test/functional/2members.test.js~describe14.describe32.describe38.it41",
    "access": null,
    "description": "private String",
    "lineNumber": 705,
    "testTargets": [
      "WebGroup#sendTo"
    ]
  },
  {
    "__docId__": 107,
    "kind": "test",
    "name": "it42",
    "testId": 42,
    "memberof": "test/functional/2members.test.js~describe14.describe32.describe38",
    "testDepth": 3,
    "static": true,
    "longname": "test/functional/2members.test.js~describe14.describe32.describe38.it42",
    "access": null,
    "description": "private ArrayBuffer",
    "lineNumber": 729,
    "testTargets": [
      "WebGroup#sendTo"
    ]
  },
  {
    "__docId__": 108,
    "kind": "testFile",
    "name": "test/functional/3members.test.js",
    "content": "\"use strict\";\n// /// <reference types='jasmine' />\n// /* tslint:disable:one-variable-per-declaration */\n// import { SignalingState, WebGroup, WebGroupState } from '../../src/index.browser'\n// import { areTheSame, cleanWebGroup, IMessages, Queue, SIGNALING_URL, wait } from '../util/helper'\n// const WebGroupOptions = {\n//   signalingServer: SIGNALING_URL,\n//   autoRejoin: false,\n// }\n// /** @test {WebGroup} */\n// describe('3 members', () => {\n//   describe('🙂 🙂 🙂', () => {\n//     let wg1: WebGroup, wg2: WebGroup, wg3: WebGroup\n//     let called1: number, called2: number, called3: number\n//     /** @test {WebGroup#join} */\n//     describe('joining', () => {\n//       beforeEach((done) => {\n//         called1 = 0\n//         called2 = 0\n//         called3 = 0\n//         const queue = new Queue(4)\n//         queue.wait().then(() => {\n//           cleanWebGroup(wg1)\n//           cleanWebGroup(wg2)\n//           cleanWebGroup(wg3)\n//           done()\n//         })\n//         wg1 = new WebGroup(WebGroupOptions)\n//         wg2 = new WebGroup(WebGroupOptions)\n//         wg3 = new WebGroup(WebGroupOptions)\n//         wg1.onSignalingStateChange = (state: SignalingState) => {\n//           if (state === SignalingState.STABLE) {\n//             wg2.join(wg1.key)\n//           }\n//         }\n//         wg1.onMemberJoin = () => queue.pop()\n//         wg2.onStateChange = (state: WebGroupState) => {\n//           if (state === WebGroup.JOINED) {\n//             queue.pop()\n//           }\n//         }\n//         wg2.onSignalingStateChange = (state: SignalingState) => {\n//           if (state === SignalingState.STABLE) {\n//             queue.pop()\n//           }\n//         }\n//         wg2.onMemberJoin = () => queue.pop()\n//         wg1.join()\n//       })\n//       afterEach((done) => {\n//         cleanWebGroup(wg1)\n//         cleanWebGroup(wg2)\n//         cleanWebGroup(wg3)\n//         const queue = new Queue(3)\n//         if (wg1.state !== WebGroup.LEFT) {\n//           wg1.onStateChange = (state: WebGroupState) => {\n//             if (state === WebGroup.LEFT) {\n//               queue.pop()\n//             }\n//           }\n//           wg1.leave()\n//         } else {\n//           queue.pop()\n//         }\n//         if (wg2.state !== WebGroup.LEFT) {\n//           wg2.onStateChange = (state: WebGroupState) => {\n//             if (state === WebGroup.LEFT) {\n//               queue.pop()\n//             }\n//           }\n//           wg2.leave()\n//         } else {\n//           queue.pop()\n//         }\n//         if (wg3.state !== WebGroup.LEFT) {\n//           wg3.onStateChange = (state: WebGroupState) => {\n//             if (state === WebGroup.LEFT) {\n//               queue.pop()\n//             }\n//           }\n//           wg3.leave()\n//         } else {\n//           queue.pop()\n//         }\n//         queue.wait().then(() => {\n//           cleanWebGroup(wg1)\n//           cleanWebGroup(wg2)\n//           cleanWebGroup(wg3)\n//           done()\n//         })\n//       })\n//       /** @test {WebGroup#onSignalingStateChange} */\n//       it('should change the Signaling state', (done) => {\n//         const states: SignalingState[] = []\n//         const expectedStates = [\n//           SignalingState.CONNECTING,\n//           SignalingState.CONNECTED,\n//           SignalingState.STABLE,\n//         ]\n//         // Code for peer 1\n//         wg1.onSignalingStateChange = () => called1++\n//         // Code for peer 2\n//         wg2.onSignalingStateChange = () => called2++\n//         // Code for peer 3\n//         wg3.onSignalingStateChange = (state: SignalingState) => {\n//           states.push(state)\n//           called3++\n//           if (state === SignalingState.STABLE) {\n//             wait(1000).then(() => {\n//               expect(called1).toEqual(0)\n//               expect(called2).toEqual(0)\n//               expect(called3).toEqual(3)\n//               expect(states).toEqual(expectedStates)\n//               expect(wg3.signalingState).toEqual(SignalingState.STABLE)\n//               done()\n//             })\n//           }\n//         }\n//         // Start joining\n//         wg3.join(wg1.key)\n//       })\n//       /** @test {WebGroup#onStateChange} */\n//       it('should change the WebGroup state', (done) => {\n//         const states: WebGroupState[] = []\n//         const expectedStates = [WebGroup.JOINING, WebGroup.JOINED]\n//         // Code for peer 1\n//         wg1.onStateChange = () => called1++\n//         // Code for peer 2\n//         wg2.onStateChange = () => called2++\n//         // Code for peer 3\n//         wg3.onStateChange = (state: WebGroupState) => {\n//           states.push(state)\n//           called3++\n//           if (state === WebGroup.JOINED) {\n//             wait(1000).then(() => {\n//               expect(called1).toEqual(0)\n//               expect(called2).toEqual(0)\n//               expect(called3).toEqual(2)\n//               expect(states).toEqual(expectedStates)\n//               expect(wg3.state).toEqual(WebGroup.JOINED)\n//               done()\n//             })\n//           }\n//         }\n//         // Start joining\n//         wg3.join(wg1.key)\n//       })\n//       /** @test {WebGroup#onMemberJoin} */\n//       it('should be notified about new member', (done) => {\n//         const members3: number[] = []\n//         const expectedMembers3 = [wg1.myId, wg2.myId]\n//         const queue = new Queue(3)\n//         queue\n//           .wait()\n//           .then(() => wait(1000))\n//           .then(() => {\n//             expect(called1).toEqual(1)\n//             expect(called2).toEqual(1)\n//             expect(called3).toEqual(2)\n//             expect(areTheSame(members3, expectedMembers3)).toBeTruthy()\n//             done()\n//           })\n//         // Code for peer 1\n//         wg1.onMemberJoin = (id) => {\n//           expect(id).toEqual(wg3.myId)\n//           called1++\n//           queue.pop()\n//         }\n//         // Code for peer 2\n//         wg2.onMemberJoin = (id) => {\n//           expect(id).toEqual(wg3.myId)\n//           called2++\n//           queue.pop()\n//         }\n//         // Code for peer 3\n//         wg3.onMemberJoin = (id) => {\n//           members3.push(id)\n//           called3++\n//           if (called3 === 2) {\n//             queue.pop()\n//           }\n//         }\n//         // Start joining\n//         wg3.join(wg1.key)\n//       })\n//       it('should have the same members, key, WebGroup id, topology once joined', (done) => {\n//         const queue = new Queue(3)\n//         queue\n//           .wait()\n//           .then(() => wait(1000))\n//           .then(() => {\n//             expect(areTheSame(wg3.members, wg1.members)).toBeTruthy()\n//             expect(areTheSame(wg3.members, wg2.members)).toBeTruthy()\n//             expect(wg3.id).toEqual(wg1.id)\n//             expect(wg3.key).toEqual(wg1.key)\n//             expect(wg3.topology).toEqual(wg1.topology)\n//             done()\n//           })\n//         // Code for peer 1\n//         wg1.onMemberJoin = () => queue.pop()\n//         // Code for peer 2\n//         wg2.onMemberJoin = () => queue.pop()\n//         // Code for peer 3\n//         wg3.onStateChange = (state: WebGroupState) => {\n//           if (state === WebGroup.JOINED) {\n//             expect(wg3.members.length).toEqual(3)\n//             expect(wg3.members.includes(wg1.myId)).toBeTruthy()\n//             expect(wg3.members.includes(wg2.myId)).toBeTruthy()\n//             expect(wg3.members.includes(wg3.myId)).toBeTruthy()\n//             expect(wg3.id).toEqual(wg1.id)\n//             expect(wg3.key).toEqual(wg1.key)\n//             expect(wg3.topology).toEqual(wg1.topology)\n//             queue.pop()\n//           }\n//         }\n//         // Start joining\n//         wg3.join(wg1.key)\n//       })\n//     })\n//     describe('should send/receive', () => {\n//       beforeEach((done) => {\n//         called1 = 0\n//         called2 = 0\n//         called3 = 0\n//         const queue = new Queue(9)\n//         wg1 = new WebGroup(WebGroupOptions)\n//         wg2 = new WebGroup(WebGroupOptions)\n//         wg3 = new WebGroup(WebGroupOptions)\n//         wg1.onSignalingStateChange = (state: SignalingState) => {\n//           if (state === SignalingState.STABLE) {\n//             wg2.join(wg1.key)\n//           }\n//         }\n//         wg1.onMemberJoin = () => queue.pop()\n//         wg1.onStateChange = (state: WebGroupState) => {\n//           if (state === WebGroup.JOINED) {\n//             queue.pop()\n//           }\n//         }\n//         wg2.onStateChange = (state: WebGroupState) => {\n//           if (state === WebGroup.JOINED) {\n//             queue.pop()\n//           }\n//         }\n//         wg2.onSignalingStateChange = (state: SignalingState) => {\n//           if (state === SignalingState.STABLE) {\n//             wg3.join(wg1.key)\n//           }\n//         }\n//         wg2.onMemberJoin = () => queue.pop()\n//         wg3.onStateChange = (state: WebGroupState) => {\n//           if (state === WebGroup.JOINED) {\n//             queue.pop()\n//           }\n//         }\n//         wg3.onMemberJoin = () => queue.pop()\n//         wg1.join()\n//         queue.wait().then(() => {\n//           cleanWebGroup(wg1)\n//           cleanWebGroup(wg2)\n//           cleanWebGroup(wg3)\n//           done()\n//         })\n//       })\n//       afterEach((done) => {\n//         cleanWebGroup(wg1)\n//         cleanWebGroup(wg2)\n//         cleanWebGroup(wg3)\n//         const queue = new Queue(3)\n//         if (wg1.state !== WebGroup.LEFT) {\n//           wg1.onStateChange = (state: WebGroupState) => {\n//             if (state === WebGroup.LEFT) {\n//               queue.pop()\n//             }\n//           }\n//           wg1.leave()\n//         } else {\n//           queue.pop()\n//         }\n//         if (wg2.state !== WebGroup.LEFT) {\n//           wg2.onStateChange = (state: WebGroupState) => {\n//             if (state === WebGroup.LEFT) {\n//               queue.pop()\n//             }\n//           }\n//           wg2.leave()\n//         } else {\n//           queue.pop()\n//         }\n//         if (wg3.state !== WebGroup.LEFT) {\n//           wg3.onStateChange = (state: WebGroupState) => {\n//             if (state === WebGroup.LEFT) {\n//               queue.pop()\n//             }\n//           }\n//           wg3.leave()\n//         } else {\n//           queue.pop()\n//         }\n//         queue.wait().then(() => {\n//           cleanWebGroup(wg1)\n//           cleanWebGroup(wg2)\n//           cleanWebGroup(wg3)\n//           done()\n//         })\n//       })\n//       /** @test {WebGroup#send} */\n//       it('broadcast String', (done) => {\n//         const queue = new Queue(6)\n//         queue\n//           .wait()\n//           .then(() => wait(1000))\n//           .then(() => {\n//             expect(called1).toEqual(2)\n//             expect(called2).toEqual(2)\n//             expect(called3).toEqual(2)\n//             expect(areTheSame(messages1.ids, [wg2.myId, wg3.myId])).toBeTruthy()\n//             expect(areTheSame(messages1.msgs, [msg2, msg3])).toBeTruthy()\n//             expect(areTheSame(messages2.ids, [wg1.myId, wg3.myId])).toBeTruthy()\n//             expect(areTheSame(messages2.msgs, [msg1, msg3])).toBeTruthy()\n//             expect(areTheSame(messages3.ids, [wg2.myId, wg1.myId])).toBeTruthy()\n//             expect(areTheSame(messages3.msgs, [msg2, msg1])).toBeTruthy()\n//             done()\n//           })\n//         const msg1 = 'Art is long, life is short'\n//         const msg2 = 'Do or do not, there is no try'\n//         const msg3 = 'Never say never'\n//         const messages1: IMessages = { ids: [], msgs: [] }\n//         const messages2: IMessages = { ids: [], msgs: [] }\n//         const messages3: IMessages = { ids: [], msgs: [] }\n//         // Code for peer 1\n//         wg1.onMessage = (id, msg) => {\n//           messages1.ids.push(id)\n//           messages1.msgs.push(msg)\n//           called1++\n//           queue.pop()\n//         }\n//         // Code for peer 2\n//         wg2.onMessage = (id, msg) => {\n//           messages2.ids.push(id)\n//           messages2.msgs.push(msg)\n//           called2++\n//           queue.pop()\n//         }\n//         // Code for peer 3\n//         wg3.onMessage = (id, msg) => {\n//           messages3.ids.push(id)\n//           messages3.msgs.push(msg)\n//           called3++\n//           queue.pop()\n//         }\n//         // Start sending message\n//         wg1.send(msg1)\n//         wg2.send(msg2)\n//         wg3.send(msg3)\n//       })\n//       /** @test {WebGroup#send} */\n//       it('broadcast ArrayBuffer', (done) => {\n//         const queue = new Queue(6)\n//         queue\n//           .wait()\n//           .then(() => wait(1000))\n//           .then(() => {\n//             expect(called1).toEqual(2)\n//             expect(called2).toEqual(2)\n//             expect(called3).toEqual(2)\n//             expect(areTheSame(messages1.ids, [wg2.myId, wg3.myId])).toBeTruthy()\n//             expect(areTheSame(messages1.msgs, [msg2, msg3])).toBeTruthy()\n//             expect(areTheSame(messages2.ids, [wg1.myId, wg3.myId])).toBeTruthy()\n//             expect(areTheSame(messages2.msgs, [msg1, msg3])).toBeTruthy()\n//             expect(areTheSame(messages3.ids, [wg2.myId, wg1.myId])).toBeTruthy()\n//             expect(areTheSame(messages3.msgs, [msg2, msg1])).toBeTruthy()\n//             done()\n//           })\n//         const msg1 = new Uint8Array([42, 347, 248247, 583, 10, 8, 9623])\n//         const msg2 = new Uint8Array([845, 4, 798240, 3290, 553, 1, 398539857, 84])\n//         const msg3 = new Uint8Array([84, 79, 240, 30, 53, 3, 339857, 44])\n//         const messages1: IMessages = { ids: [], msgs: [] }\n//         const messages2: IMessages = { ids: [], msgs: [] }\n//         const messages3: IMessages = { ids: [], msgs: [] }\n//         // Code for peer 1\n//         wg1.onMessage = (id, msg) => {\n//           expect(msg instanceof Uint8Array).toBeTruthy()\n//           messages1.ids.push(id)\n//           messages1.msgs.push(msg)\n//           called1++\n//           queue.pop()\n//         }\n//         // Code for peer 2\n//         wg2.onMessage = (id, msg) => {\n//           expect(msg instanceof Uint8Array).toBeTruthy()\n//           messages2.ids.push(id)\n//           messages2.msgs.push(msg)\n//           called2++\n//           queue.pop()\n//         }\n//         // Code for peer 3\n//         wg3.onMessage = (id, msg) => {\n//           expect(msg instanceof Uint8Array).toBeTruthy()\n//           messages3.ids.push(id)\n//           messages3.msgs.push(msg)\n//           called3++\n//           queue.pop()\n//         }\n//         // Start sending message\n//         wg1.send(msg1)\n//         wg2.send(msg2)\n//         wg3.send(msg3)\n//       })\n//       /** @test {WebGroup#sendTo} */\n//       it('private String', (done) => {\n//         const queue = new Queue(6)\n//         queue\n//           .wait()\n//           .then(() => wait(1000))\n//           .then(() => {\n//             expect(called1).toEqual(2)\n//             expect(called2).toEqual(2)\n//             expect(called3).toEqual(2)\n//             expect(areTheSame(messages1.ids, [wg2.myId, wg3.myId])).toBeTruthy()\n//             expect(areTheSame(messages1.msgs, [msg2For1, msg3For1])).toBeTruthy()\n//             expect(areTheSame(messages2.ids, [wg1.myId, wg3.myId])).toBeTruthy()\n//             expect(areTheSame(messages2.msgs, [msg1For2, msg3For2])).toBeTruthy()\n//             expect(areTheSame(messages3.ids, [wg2.myId, wg1.myId])).toBeTruthy()\n//             expect(areTheSame(messages3.msgs, [msg2For3, msg1For3])).toBeTruthy()\n//             done()\n//           })\n//         const msg1For2 = 'Art is long, life is short2'\n//         const msg1For3 = 'Art is long, life is short3'\n//         const msg2For1 = 'Do or do not, there is no try1'\n//         const msg2For3 = 'Do or do not, there is no try3'\n//         const msg3For1 = 'Never say never1'\n//         const msg3For2 = 'Never say never2'\n//         const messages1: IMessages = { ids: [], msgs: [] }\n//         const messages2: IMessages = { ids: [], msgs: [] }\n//         const messages3: IMessages = { ids: [], msgs: [] }\n//         // Code for peer 1\n//         wg1.onMessage = (id, msg) => {\n//           messages1.ids.push(id)\n//           messages1.msgs.push(msg)\n//           called1++\n//           queue.pop()\n//         }\n//         // Code for peer 2\n//         wg2.onMessage = (id, msg) => {\n//           messages2.ids.push(id)\n//           messages2.msgs.push(msg)\n//           called2++\n//           queue.pop()\n//         }\n//         // Code for peer 3\n//         wg3.onMessage = (id, msg) => {\n//           messages3.ids.push(id)\n//           messages3.msgs.push(msg)\n//           called3++\n//           queue.pop()\n//         }\n//         // Start sending message\n//         wg1.sendTo(wg2.myId, msg1For2)\n//         wg1.sendTo(wg3.myId, msg1For3)\n//         wg2.sendTo(wg1.myId, msg2For1)\n//         wg2.sendTo(wg3.myId, msg2For3)\n//         wg3.sendTo(wg1.myId, msg3For1)\n//         wg3.sendTo(wg2.myId, msg3For2)\n//       })\n//       /** @test {WebGroup#sendTo} */\n//       it('private ArrayBuffer', (done) => {\n//         const queue = new Queue(6)\n//         queue\n//           .wait()\n//           .then(() => wait(1000))\n//           .then(() => {\n//             expect(called1).toEqual(2)\n//             expect(called2).toEqual(2)\n//             expect(called3).toEqual(2)\n//             expect(areTheSame(messages1.ids, [wg2.myId, wg3.myId])).toBeTruthy()\n//             expect(areTheSame(messages1.msgs, [msg2For1, msg3For1])).toBeTruthy()\n//             expect(areTheSame(messages2.ids, [wg1.myId, wg3.myId])).toBeTruthy()\n//             expect(areTheSame(messages2.msgs, [msg1For2, msg3For2])).toBeTruthy()\n//             expect(areTheSame(messages3.ids, [wg2.myId, wg1.myId])).toBeTruthy()\n//             expect(areTheSame(messages3.msgs, [msg2For3, msg1For3])).toBeTruthy()\n//             done()\n//           })\n//         const msg1For2 = new Uint8Array([42, 347, 248247, 583, 10, 8, 2])\n//         const msg1For3 = new Uint8Array([42, 347, 248247, 583, 10, 8, 3])\n//         const msg2For1 = new Uint8Array([845, 4, 798240, 3290, 553, 1, 398539857, 1])\n//         const msg2For3 = new Uint8Array([845, 4, 798240, 3290, 553, 1, 398539857, 3])\n//         const msg3For1 = new Uint8Array([84, 79, 240, 30, 53, 3, 339857, 1])\n//         const msg3For2 = new Uint8Array([84, 79, 240, 30, 53, 3, 339857, 2])\n//         const messages1: IMessages = { ids: [], msgs: [] }\n//         const messages2: IMessages = { ids: [], msgs: [] }\n//         const messages3: IMessages = { ids: [], msgs: [] }\n//         // Code for peer 1\n//         wg1.onMessage = (id, msg) => {\n//           expect(msg instanceof Uint8Array).toBeTruthy()\n//           messages1.ids.push(id)\n//           messages1.msgs.push(msg)\n//           called1++\n//           queue.pop()\n//         }\n//         // Code for peer 2\n//         wg2.onMessage = (id, msg) => {\n//           expect(msg instanceof Uint8Array).toBeTruthy()\n//           messages2.ids.push(id)\n//           messages2.msgs.push(msg)\n//           called2++\n//           queue.pop()\n//         }\n//         // Code for peer 3\n//         wg3.onMessage = (id, msg) => {\n//           expect(msg instanceof Uint8Array).toBeTruthy()\n//           messages3.ids.push(id)\n//           messages3.msgs.push(msg)\n//           called3++\n//           queue.pop()\n//         }\n//         // Start sending message\n//         wg1.sendTo(wg2.myId, msg1For2)\n//         wg1.sendTo(wg3.myId, msg1For3)\n//         wg2.sendTo(wg1.myId, msg2For1)\n//         wg2.sendTo(wg3.myId, msg2For3)\n//         wg3.sendTo(wg1.myId, msg3For1)\n//         wg3.sendTo(wg2.myId, msg3For2)\n//       })\n//     })\n//     // TODO: finish test\n//     xdescribe('leaving', () => {\n//       beforeEach((done) => {\n//         called1 = 0\n//         called2 = 0\n//         called3 = 0\n//         const queue = new Queue(4)\n//         queue.wait().then(() => {\n//           cleanWebGroup(wg1)\n//           cleanWebGroup(wg2)\n//           cleanWebGroup(wg3)\n//           done()\n//         })\n//         wg1 = new WebGroup(WebGroupOptions)\n//         wg2 = new WebGroup(WebGroupOptions)\n//         wg3 = new WebGroup(WebGroupOptions)\n//         wg1.onSignalingStateChange = (state: SignalingState) => {\n//           if (state === SignalingState.STABLE) {\n//             wg2.join(wg1.key)\n//           }\n//         }\n//         wg1.onMemberJoin = () => queue.pop()\n//         wg2.onStateChange = (state: WebGroupState) => {\n//           if (state === WebGroup.JOINED) {\n//             queue.pop()\n//           }\n//         }\n//         wg2.onSignalingStateChange = (state: SignalingState) => {\n//           if (state === SignalingState.STABLE) {\n//             queue.pop()\n//           }\n//         }\n//         wg2.onMemberJoin = () => queue.pop()\n//         wg1.join()\n//       })\n//       afterEach((done) => {\n//         cleanWebGroup(wg1)\n//         cleanWebGroup(wg2)\n//         cleanWebGroup(wg3)\n//         const queue = new Queue(3)\n//         if (wg1.state !== WebGroup.LEFT) {\n//           wg1.onStateChange = (state: WebGroupState) => {\n//             if (state === WebGroup.LEFT) {\n//               queue.pop()\n//             }\n//           }\n//           wg1.leave()\n//         } else {\n//           queue.pop()\n//         }\n//         if (wg2.state !== WebGroup.LEFT) {\n//           wg2.onStateChange = (state: WebGroupState) => {\n//             if (state === WebGroup.LEFT) {\n//               queue.pop()\n//             }\n//           }\n//           wg2.leave()\n//         } else {\n//           queue.pop()\n//         }\n//         if (wg3.state !== WebGroup.LEFT) {\n//           wg3.onStateChange = (state: WebGroupState) => {\n//             if (state === WebGroup.LEFT) {\n//               queue.pop()\n//             }\n//           }\n//           wg3.leave()\n//         } else {\n//           queue.pop()\n//         }\n//         queue.wait().then(() => {\n//           cleanWebGroup(wg1)\n//           cleanWebGroup(wg2)\n//           cleanWebGroup(wg3)\n//           done()\n//         })\n//       })\n//       /** @test {WebGroup#leave} */\n//       it('should have no members & an empty key', (done) => {\n//         const queue = new Queue(1)\n//         // Code for peer 1\n//         wg1.onMemberLeave = () => {\n//           expect(wg1.members.length).toEqual(1)\n//           expect(wg1.members.includes(wg1.myId)).toBeTruthy()\n//           queue.pop()\n//         }\n//         // Code for peer 2\n//         wg2.onStateChange = (state: WebGroupState) => {\n//           if (state === WebGroup.LEFT) {\n//             called2++\n//             expect(wg2.members.length).toEqual(1)\n//             expect(wg2.members.includes(wg2.myId)).toBeTruthy()\n//             expect(wg2.key).toEqual('')\n//             queue\n//               .wait()\n//               .then(() => wait(1000))\n//               .then(() => {\n//                 expect(wg1.members.length).toEqual(1)\n//                 expect(wg1.members.includes(wg1.myId)).toBeTruthy()\n//                 expect(wg2.members.length).toEqual(1)\n//                 expect(wg2.members.includes(wg2.myId)).toBeTruthy()\n//                 expect(wg2.key).toEqual('')\n//                 expect(called2).toEqual(1)\n//                 expect(wg2.key).toEqual('')\n//                 done()\n//               })\n//           }\n//         }\n//         // Start leaving\n//         wg2.leave()\n//       })\n//       /** @test {WebGroup#onMemberLeave} */\n//       it('should be notified about left member', (done) => {\n//         const queue = new Queue(2)\n//         // Code for peer 1\n//         wg1.onMemberLeave = (id) => {\n//           expect(id).toEqual(wg2.myId)\n//           called1++\n//           queue.pop()\n//         }\n//         // Code for peer 2\n//         wg2.onMemberLeave = (id) => {\n//           expect(id).toEqual(wg1.myId)\n//           called2++\n//           queue.pop()\n//         }\n//         // Start leaving\n//         wg2.leave()\n//         // When finish test\n//         queue.wait().then(() => {\n//           wait(1000).then(() => {\n//             expect(called1).toEqual(1)\n//             expect(called2).toEqual(1)\n//             done()\n//           })\n//         })\n//       })\n//       /** @test {WebGroup#onStateChange} */\n//       it('should change the WebGroup state', (done) => {\n//         // Code for peer 2\n//         wg2.onStateChange = (state: WebGroupState) => {\n//           if (state === WebGroup.LEFT) {\n//             called2++\n//           }\n//           wait(1000).then(() => {\n//             expect(called2).toEqual(1)\n//             expect(wg2.state).toEqual(WebGroup.LEFT)\n//             done()\n//           })\n//         }\n//         // Start leaving\n//         wg2.leave()\n//       })\n//       /** @test {WebGroup#onSignalingStateChange} */\n//       it('should change the Signaling state', (done) => {\n//         // Code for peer 2\n//         wg2.onSignalingStateChange = (state: SignalingState) => {\n//           if (state === SignalingState.CLOSED) {\n//             called2++\n//           }\n//           wait(1000).then(() => {\n//             expect(called2).toEqual(1)\n//             expect(wg2.signalingState).toEqual(SignalingState.CLOSED)\n//             done()\n//           })\n//         }\n//         // Start leaving\n//         wg2.leave()\n//       })\n//     })\n//   })\n// })\n",
    "static": true,
    "longname": "/home/philippe/workspace/netflux/docs/jsFromTs/test/functional/3members.test.js",
    "access": null,
    "description": null,
    "lineNumber": 1
  }
]