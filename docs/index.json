[
  {
    "__docId__": 0,
    "kind": "file",
    "name": "src/BotServerFacade.js",
    "content": "import { BotServer } from './BotServer';\nlet botServer;\n/**\n * Bot server may be a member of severals groups. Each group is isolated.\n * He can be invited by a group member via {@link WebGroup#invite} method.\n * @example\n * // In NodeJS:\n * // Create a bot server with full mesh topology, without autorejoin feature\n * // and with specified Signaling and ICE servers for WebRTC.\n * // Bot server is listening on 'ws://BOT_HOST:BOT_PORT'.\n *\n * const http = require('http')\n * const server = http.createServer(app.callback())\n * const bot = new WebGroupBotServer({\n *   server,\n *   webGroupOptions: {\n *     signalingURL: 'wss://mysignaling.com'\n *     iceServers: [\n *       {\n *         urls: 'stun.l.google.com:19302'\n *       },\n *       {\n *         urls: ['turn:myturn.com?transport=udp', 'turn:myturn?transport=tcp'],\n *         username: 'user',\n *         password: 'password'\n *       }\n *     ]\n *   }\n * })\n *\n * bot.onWebGroup = (wg) => {\n *   // YOUR CODE\n * }\n *\n * bot.onError = (err) => {\n *   // YOUR CODE\n * }\n *\n * server.listen(BOT_PORT, BOT_HOST)\n */\nexport class WebGroupBotServer {\n    /**\n     * @param {WebGroupBotServerOptions} options\n     * @param {NodeJSHttpServer|NodeJSHttpsServer} options.server NodeJS http(s) server.\n     * @param {string} [options.url] Bot server URL.\n     * @param {boolean} [options.perMessageDeflate=false] Enable/disable permessage-deflate.\n     * @param {WebGroupOptions} options.webGroupOptions Options for each {@link WebGroup} the bot is member of.\n     * @param {Topology} [options.webGroupOptions.topology=Topology.FULL_MESH]\n     * @param {string} [options.webGroupOptions.signalingURL='wss://www.coedit.re:30443']\n     * @param {RTCIceServer[]} [options.webGroupOptions.iceServers=[{urls: 'stun:stun3.l.google.com:19302'}]]\n     * @param {boolean} [options.webGroupOptions.autoRejoin=false]\n     */\n    constructor(options) {\n        botServer = new BotServer(options);\n        /**\n         * Read-only NodeJS http server instance.\n         * @type {NodeJSHttpServer|NodeJSHttpsServer}\n         */\n        this.server = undefined;\n        Reflect.defineProperty(this, 'server', { configurable: false, enumerable: true, get: () => botServer.server });\n        /**\n         * Read-only property of WebSocket server: permessage-deflate.\n         * @type {NodeJSHttpServer|NodeJSHttpsServer}\n         */\n        this.perMessageDeflate = undefined;\n        Reflect.defineProperty(this, 'perMessageDeflate', {\n            configurable: false,\n            enumerable: true,\n            get: () => botServer.perMessageDeflate,\n        });\n        /**\n         * Read-only set of web groups the bot is member of.\n         * @type {Set<WebGroup>}\n         */\n        this.webGroups = undefined;\n        Reflect.defineProperty(this, 'webGroups', { configurable: false, enumerable: true, get: () => botServer.webGroups });\n        /**\n         * Bot server url. Used to invite the bot in a web group via {@link WebGroup#invite} method.\n         * @type {string}\n         */\n        this.url = undefined;\n        Reflect.defineProperty(this, 'url', { configurable: false, enumerable: true, get: () => botServer.url });\n        /**\n         * This handler is called when the bot has been invited into a group by one of its members.\n         * @type  {function(wg: WebGroup)} handler\n         */\n        this.onWebGroup = undefined;\n        Reflect.defineProperty(this, 'onWebGroup', {\n            configurable: true,\n            enumerable: true,\n            get: () => (botServer.onWebGroup.name === 'none') ? undefined : botServer.onWebGroup,\n            set: (handler) => {\n                if (typeof handler !== 'function') {\n                    botServer.onWebGroup = function none() { };\n                }\n                else {\n                    botServer.onWebGroup = handler;\n                }\n            },\n        });\n        /**\n         * This handler is called when an error occurs on WebSocket server.\n         * @type  {function(err: Error)}\n         */\n        this.onError = undefined;\n        Reflect.defineProperty(this, 'onError', {\n            configurable: true,\n            enumerable: true,\n            get: () => (botServer.onError.name === 'none') ? undefined : botServer.onError,\n            set: (handler) => {\n                if (typeof handler !== 'function') {\n                    botServer.onError = function none() { };\n                }\n                else {\n                    botServer.onError = handler;\n                }\n            },\n        });\n    }\n}\n",
    "static": true,
    "longname": "/home/philippe/workspace/netflux/docs/jsFromTs/src/BotServerFacade.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 1,
    "kind": "class",
    "name": "WebGroupBotServer",
    "memberof": "src/BotServerFacade.js",
    "static": true,
    "longname": "src/BotServerFacade.js~WebGroupBotServer",
    "access": "public",
    "export": true,
    "importPath": "netflux/src/BotServerFacade.js",
    "importStyle": "{WebGroupBotServer}",
    "description": "Bot server may be a member of severals groups. Each group is isolated.\nHe can be invited by a group member via {@link WebGroup#invite} method.",
    "examples": [
      "// In NodeJS:\n// Create a bot server with full mesh topology, without autorejoin feature\n// and with specified Signaling and ICE servers for WebRTC.\n// Bot server is listening on 'ws://BOT_HOST:BOT_PORT'.\n\nconst http = require('http')\nconst server = http.createServer(app.callback())\nconst bot = new WebGroupBotServer({\n  server,\n  webGroupOptions: {\n    signalingURL: 'wss://mysignaling.com'\n    iceServers: [\n      {\n        urls: 'stun.l.google.com:19302'\n      },\n      {\n        urls: ['turn:myturn.com?transport=udp', 'turn:myturn?transport=tcp'],\n        username: 'user',\n        password: 'password'\n      }\n    ]\n  }\n})\n\nbot.onWebGroup = (wg) => {\n  // YOUR CODE\n}\n\nbot.onError = (err) => {\n  // YOUR CODE\n}\n\nserver.listen(BOT_PORT, BOT_HOST)"
    ],
    "lineNumber": 41,
    "interface": false
  },
  {
    "__docId__": 2,
    "kind": "constructor",
    "name": "constructor",
    "memberof": "src/BotServerFacade.js~WebGroupBotServer",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/BotServerFacade.js~WebGroupBotServer#constructor",
    "access": "public",
    "description": "",
    "lineNumber": 53,
    "params": [
      {
        "nullable": null,
        "types": [
          "WebGroupBotServerOptions"
        ],
        "spread": false,
        "optional": false,
        "name": "options",
        "description": ""
      },
      {
        "nullable": null,
        "types": [
          "NodeJSHttpServer",
          "NodeJSHttpsServer"
        ],
        "spread": false,
        "optional": false,
        "name": "options.server",
        "description": "NodeJS http(s) server."
      },
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": true,
        "name": "options.url",
        "description": "Bot server URL."
      },
      {
        "nullable": null,
        "types": [
          "boolean"
        ],
        "spread": false,
        "optional": true,
        "defaultValue": "false",
        "defaultRaw": false,
        "name": "options.perMessageDeflate",
        "description": "Enable/disable permessage-deflate."
      },
      {
        "nullable": null,
        "types": [
          "WebGroupOptions"
        ],
        "spread": false,
        "optional": false,
        "name": "options.webGroupOptions",
        "description": "Options for each {@link WebGroup} the bot is member of."
      },
      {
        "nullable": null,
        "types": [
          "Topology"
        ],
        "spread": false,
        "optional": true,
        "defaultValue": "Topology.FULL_MESH",
        "defaultRaw": "Topology.FULL_MESH",
        "name": "options.webGroupOptions.topology",
        "description": ""
      },
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": true,
        "defaultValue": "'wss://www.coedit.re:30443'",
        "defaultRaw": "'wss://www.coedit.re:30443'",
        "name": "options.webGroupOptions.signalingURL",
        "description": ""
      },
      {
        "nullable": null,
        "types": [
          "RTCIceServer[]"
        ],
        "spread": false,
        "optional": true,
        "defaultValue": "[{urls: 'stun:stun3.l.google.com:19302'}]",
        "defaultRaw": "[{urls: 'stun:stun3.l.google.com:19302'}]",
        "name": "options.webGroupOptions.iceServers",
        "description": ""
      },
      {
        "nullable": null,
        "types": [
          "boolean"
        ],
        "spread": false,
        "optional": true,
        "defaultValue": "false",
        "defaultRaw": false,
        "name": "options.webGroupOptions.autoRejoin",
        "description": ""
      }
    ]
  },
  {
    "__docId__": 3,
    "kind": "member",
    "name": "server",
    "memberof": "src/BotServerFacade.js~WebGroupBotServer",
    "static": false,
    "longname": "src/BotServerFacade.js~WebGroupBotServer#server",
    "access": "public",
    "description": "Read-only NodeJS http server instance.",
    "lineNumber": 59,
    "type": {
      "nullable": null,
      "types": [
        "NodeJSHttpServer",
        "NodeJSHttpsServer"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 4,
    "kind": "member",
    "name": "perMessageDeflate",
    "memberof": "src/BotServerFacade.js~WebGroupBotServer",
    "static": false,
    "longname": "src/BotServerFacade.js~WebGroupBotServer#perMessageDeflate",
    "access": "public",
    "description": "Read-only property of WebSocket server: permessage-deflate.",
    "lineNumber": 65,
    "type": {
      "nullable": null,
      "types": [
        "NodeJSHttpServer",
        "NodeJSHttpsServer"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 5,
    "kind": "member",
    "name": "webGroups",
    "memberof": "src/BotServerFacade.js~WebGroupBotServer",
    "static": false,
    "longname": "src/BotServerFacade.js~WebGroupBotServer#webGroups",
    "access": "public",
    "description": "Read-only set of web groups the bot is member of.",
    "lineNumber": 75,
    "type": {
      "nullable": null,
      "types": [
        "Set<WebGroup>"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 6,
    "kind": "member",
    "name": "url",
    "memberof": "src/BotServerFacade.js~WebGroupBotServer",
    "static": false,
    "longname": "src/BotServerFacade.js~WebGroupBotServer#url",
    "access": "public",
    "description": "Bot server url. Used to invite the bot in a web group via {@link WebGroup#invite} method.",
    "lineNumber": 81,
    "type": {
      "nullable": null,
      "types": [
        "string"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 7,
    "kind": "member",
    "name": "onWebGroup",
    "memberof": "src/BotServerFacade.js~WebGroupBotServer",
    "static": false,
    "longname": "src/BotServerFacade.js~WebGroupBotServer#onWebGroup",
    "access": "public",
    "description": "This handler is called when the bot has been invited into a group by one of its members.",
    "lineNumber": 87,
    "type": {
      "nullable": null,
      "types": [
        "function(wg: WebGroup)"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 8,
    "kind": "member",
    "name": "onError",
    "memberof": "src/BotServerFacade.js~WebGroupBotServer",
    "static": false,
    "longname": "src/BotServerFacade.js~WebGroupBotServer#onError",
    "access": "public",
    "description": "This handler is called when an error occurs on WebSocket server.",
    "lineNumber": 105,
    "type": {
      "nullable": null,
      "types": [
        "function(err: Error)"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 9,
    "kind": "file",
    "name": "src/WebChannelFacade.js",
    "content": "import { WebChannel, WebChannelState } from './service/WebChannel';\n/**\n * Is a helper type representing types that can be sent/received over a web group.\n * @typedef {string|Uint8Array} DataType\n */\n/**\n * @ignore\n */\nexport const wcs = new WeakMap();\n/**\n * {@link WebGroup} state enum.\n * @type {Object}\n * @property {number} [JOINING=0] You are joining the web group.\n * @property {number} [JOINED=1] You have successfully joined the web group\n * and ready to broadcast messages via `send` method.\n * @property {number} [LEFT=2] You have left the web group. If the connection\n * to the web group has lost and `autoRejoin=true`, then the state would be `LEFT`,\n * (usually during a relatively short period) before the rejoining process start.\n */\nexport class WebGroupState {\n    /**\n     * Joining the group...\n     * @type {number}\n     */\n    static get JOINING() { return WebChannelState.JOINING; }\n    /**\n     * Equals to `'JOINING'`.\n     * @type {string}\n     */\n    static get [WebGroupState.JOINING]() { return WebChannelState[WebChannelState.JOINING]; }\n    /**\n     * Joined the group successfully.\n     * @type {number}\n     */\n    static get JOINED() { return WebChannelState.JOINED; }\n    /**\n     * Equals to `'JOINED'`.\n     * @type {string}\n     */\n    static get [WebGroupState.JOINED]() { return WebChannelState[WebChannelState.JOINED]; }\n    /**\n     * Left the group. If the connection to the web group has lost other then\n     * by calling {@link WebGroup#leave} or {@link WebGroup#closeSignaling} methods\n     * and {@link WebGroup#autoRejoin} is true, then the state would be `LEFT`,\n     * (usually during a relatively short period) before the rejoining process start.\n     * @type {number}\n     */\n    static get LEFT() { return WebChannelState.LEFT; }\n    /**\n     * Equals to `'LEFT'`.\n     * @type {string}\n     */\n    static get [WebGroupState.LEFT]() { return WebChannelState[WebChannelState.LEFT]; }\n}\n/**\n * This class is an API starting point. It represents a peer to peer network,\n * simply called a group. Each group member can send/receive broadcast\n * as well as personal messages, invite other persons or bots (see {@link WebGroupBotServer}).\n * @example\n * // Create a WebGroup with full mesh topology, autorejoin feature and\n * // specified Signaling and ICE servers for WebRTC.\n *\n * const wg = new WebGroup({\n *   signalingURL: 'wss://mysignaling.com'\n *   iceServers: [\n *     {\n *       urls: 'stun.l.google.com:19302'\n *     },\n *     {\n *       urls: ['turn:myturn.com?transport=udp', 'turn:myturn?transport=tcp'],\n *       username: 'user',\n *       password: 'password'\n *     }\n *   ]\n * })\n *\n * wg.onMemberJoin = (id) => {\n *   // YOUR CODE...\n * }\n * wg.onMemberLeave = (id) => {\n *   // YOUR CODE...\n * }\n * wg.onMessage = (id, data, isBroadcast) => {\n *   // YOUR CODE...\n * }\n * wg.onStateChange = (state) => {\n *   // YOUR CODE...\n * }\n * wg.onSignalingStateChange = (state) => {\n *   // YOUR CODE...\n * }\n */\nexport class WebGroup {\n    /**\n     * @param {WebGroupOptions} [options]\n     * @param {Topology} [options.topology=Topology.FULL_MESH]\n     * @param {string} [options.signalingURL='wss://www.coedit.re:30443']\n     * @param {RTCIceServer[]} [options.iceServers=[{urls: 'stun:stun3.l.google.com:19302'}]]\n     * @param {boolean} [options.autoRejoin=true]\n     */\n    constructor(options = {}) {\n        const wc = new WebChannel(options);\n        wcs.set(this, wc);\n        /**\n         * The read-only {@link WebGroup} identifier. The same value for all members.\n         * @type {number}\n         */\n        this.id = undefined;\n        Reflect.defineProperty(this, 'id', { configurable: false, enumerable: true, get: () => wc.id });\n        /**\n         * The read-only your unique member identifier in the group.\n         * @type {number}\n         */\n        this.myId = undefined;\n        Reflect.defineProperty(this, 'myId', { configurable: false, enumerable: true, get: () => wc.myId });\n        /**\n         * The read-only group session identifier. Equals to an empty string before calling {@link WebGroup#join}.\n         * Different to {@link WebGroup#id}. This key is known and used by Signaling server\n         * in order to join new members, on the other hand Signaling does not know {@link WebGroup#id}.\n         * @type {string}\n         */\n        this.key = undefined;\n        Reflect.defineProperty(this, 'key', { configurable: false, enumerable: true, get: () => wc.key });\n        /**\n         * The read-only array of all members including yourself (i.e. {@link WebGroup#myId})\n         * @type {number[]}\n         */\n        this.members = undefined;\n        Reflect.defineProperty(this, 'members', { configurable: false, enumerable: true, get: () => wc.members });\n        /**\n         * The read-only property which is an enum of type {@link Topology}\n         * indicating the topology used for this {@link WebGroup} instance.\n         * @type {Topology}\n         */\n        this.topology = undefined;\n        Reflect.defineProperty(this, 'topology', { configurable: false, enumerable: true, get: () => wc.topology });\n        /**\n         * The read-only state of the {@link WebGroup} connection.\n         * @type {WebGroupState}\n         */\n        this.state = undefined;\n        Reflect.defineProperty(this, 'state', { configurable: false, enumerable: true, get: () => wc.state });\n        /**\n         * The read-only state of the signaling server.\n         * @type {SignalingState}\n         */\n        this.signalingState = undefined;\n        Reflect.defineProperty(this, 'signalingState', {\n            configurable: false,\n            enumerable: true,\n            get: () => wc.signaling.state,\n        });\n        /**\n         * The read-only signaling server URL.\n         * @type {string}\n         */\n        this.signalingURL = undefined;\n        Reflect.defineProperty(this, 'signalingURL', { configurable: false, enumerable: true, get: () => wc.signaling.url });\n        /**\n         * Enable/Desable the auto rejoin feature.\n         * @type {boolean}\n         */\n        this.autoRejoin = undefined;\n        Reflect.defineProperty(this, 'autoRejoin', {\n            configurable: false,\n            enumerable: true,\n            get: () => wc.autoRejoin,\n            set: (value) => wc.autoRejoin = value,\n        });\n        /**\n         * This handler is called when a message has been received from the group.\n         * `id` is an identifier of the member who sent this message.\n         * `isBroadcast` aquals to true if the data is sent via {@link WebGroup#send}\n         * and false if sent via {@link WebGroup#sendTo}.\n         * @type {function(id: number, data: DataType, isBroadcast: boolean)}\n         */\n        this.onMessage = undefined;\n        Reflect.defineProperty(this, 'onMessage', {\n            configurable: true,\n            enumerable: true,\n            get: () => (wc.onMessage.name === 'none') ? undefined : wc.onMessage,\n            set: (handler) => {\n                if (typeof handler !== 'function') {\n                    wc.onMessage = function none() { };\n                }\n                else {\n                    wc.onMessage = handler;\n                }\n            },\n        });\n        /**\n         * This handler is called when a new member with `id` as identifier has joined the group.\n         * @type {function(id: number)}\n         */\n        this.onMemberJoin = undefined;\n        Reflect.defineProperty(this, 'onMemberJoin', {\n            configurable: true,\n            enumerable: true,\n            get: () => (wc.onMemberJoin.name === 'none') ? undefined : wc.onMemberJoin,\n            set: (handler) => {\n                if (typeof handler !== 'function') {\n                    wc.onMemberJoin = function none() { };\n                }\n                else {\n                    wc.onMemberJoin = handler;\n                }\n            },\n        });\n        /**\n         * This handler is called when a member with `id` as identifier hes left the group.\n         * @type {function(id: number)}\n         */\n        this.onMemberLeave = undefined;\n        Reflect.defineProperty(this, 'onMemberLeave', {\n            configurable: true,\n            enumerable: true,\n            get: () => (wc.onMemberLeave.name === 'none') ? undefined : wc.onMemberLeave,\n            set: (handler) => {\n                if (typeof handler !== 'function') {\n                    wc.onMemberLeave = function none() { };\n                }\n                else {\n                    wc.onMemberLeave = handler;\n                }\n            },\n        });\n        /**\n         * This handler is called when the group state has changed.\n         * @type {function(state: WebGroupState)}\n         */\n        this.onStateChange = undefined;\n        Reflect.defineProperty(this, 'onStateChange', {\n            configurable: true,\n            enumerable: true,\n            get: () => (wc.onStateChange.name === 'none') ? undefined : wc.onStateChange,\n            set: (handler) => {\n                if (typeof handler !== 'function') {\n                    wc.onStateChange = function none() { };\n                }\n                else {\n                    wc.onStateChange = handler;\n                }\n            },\n        });\n        /**\n         * This handler is called when the signaling state has changed.\n         * @type {function(state: SignalingState)}\n         */\n        this.onSignalingStateChange = undefined;\n        Reflect.defineProperty(this, 'onSignalingStateChange', {\n            configurable: true,\n            enumerable: true,\n            get: () => (wc.onSignalingStateChange.name === 'none') ? undefined : wc.onSignalingStateChange,\n            set: (handler) => {\n                if (typeof handler !== 'function') {\n                    wc.onSignalingStateChange = function none() { };\n                }\n                else {\n                    wc.onSignalingStateChange = handler;\n                }\n            },\n        });\n    }\n    /**\n     * Join the group identified by a key provided by one of the group member.\n     * If the current {@link WebGroup#state} value is not {@link WebGroupState#LEFT} or\n     * {@link WebGroup#signalingState} value is not {@link SignalingState.CLOSED},\n     * then do nothing.\n     * @param {string} [key] Will be generated if not provided\n     */\n    join(key) { return wcs.get(this).join(key); }\n    /**\n     * Invite a bot server to join this group.\n     * @param {string} url - Bot server URL (See {@link WebGroupBotServerOptions})\n     */\n    invite(url) { return wcs.get(this).invite(url); }\n    /**\n     * Close the connection with Signaling server. It fires Signaling state event\n     * if {@link WebGroup#signalingState} value does not equal to\n     * {@link SignalingState.CLOSED} already.It may also fire state event only\n     * if there is no one left in the group.\n     * value does not equal to {@link SignalingState.CLOSED} already.\n     */\n    closeSignaling() { return wcs.get(this).closeSignaling(); }\n    /**\n     * Leave the group which means close channels with all members and connection\n     * with the Signaling server.\n     */\n    leave() { return wcs.get(this).leave(); }\n    /**\n     * Broadcast a message to the group.\n     * @param {DataType} data\n     */\n    send(data) { return wcs.get(this).send(data); }\n    /**\n     * Send a message to a particular group member.\n     * @param {number}    id Member identifier\n     * @param {DataType}  data Message\n     */\n    sendTo(id, data) { return wcs.get(this).sendTo(id, data); }\n    /**\n     * Get web group latency\n     * @return {Promise<number>} Latency in milliseconds\n     */\n    ping() { return wcs.get(this).ping(); }\n}\n",
    "static": true,
    "longname": "/home/philippe/workspace/netflux/docs/jsFromTs/src/WebChannelFacade.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 10,
    "kind": "typedef",
    "name": "DataType",
    "memberof": "src/WebChannelFacade.js",
    "static": true,
    "longname": "src/WebChannelFacade.js~DataType",
    "access": "public",
    "description": "Is a helper type representing types that can be sent/received over a web group.",
    "type": {
      "types": [
        "string",
        "Uint8Array"
      ],
      "optional": false,
      "name": "DataType"
    }
  },
  {
    "__docId__": 11,
    "kind": "variable",
    "name": "wcs",
    "memberof": "src/WebChannelFacade.js",
    "static": true,
    "longname": "src/WebChannelFacade.js~wcs",
    "access": "public",
    "export": true,
    "importPath": "netflux/src/WebChannelFacade.js",
    "importStyle": "{wcs}",
    "description": "",
    "lineNumber": 9,
    "ignore": true
  },
  {
    "__docId__": 12,
    "kind": "class",
    "name": "WebGroupState",
    "memberof": "src/WebChannelFacade.js",
    "static": true,
    "longname": "src/WebChannelFacade.js~WebGroupState",
    "access": "public",
    "export": true,
    "importPath": "netflux/src/WebChannelFacade.js",
    "importStyle": "{WebGroupState}",
    "description": "{@link WebGroup} state enum.",
    "lineNumber": 20,
    "properties": [
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": true,
        "defaultValue": "0",
        "defaultRaw": 0,
        "name": "JOINING",
        "description": "You are joining the web group."
      },
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": true,
        "defaultValue": "1",
        "defaultRaw": 1,
        "name": "JOINED",
        "description": "You have successfully joined the web group\nand ready to broadcast messages via `send` method."
      },
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": true,
        "defaultValue": "2",
        "defaultRaw": 2,
        "name": "LEFT",
        "description": "You have left the web group. If the connection\nto the web group has lost and `autoRejoin=true`, then the state would be `LEFT`,\n(usually during a relatively short period) before the rejoining process start."
      }
    ],
    "type": {
      "nullable": null,
      "types": [
        "Object"
      ],
      "spread": false,
      "description": null
    },
    "interface": false
  },
  {
    "__docId__": 13,
    "kind": "get",
    "name": "JOINING",
    "memberof": "src/WebChannelFacade.js~WebGroupState",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/WebChannelFacade.js~WebGroupState.JOINING",
    "access": "public",
    "description": "Joining the group...",
    "lineNumber": 25,
    "type": {
      "nullable": null,
      "types": [
        "number"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 14,
    "kind": "get",
    "name": "[WebGroupState.JOINING]",
    "memberof": "src/WebChannelFacade.js~WebGroupState",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/WebChannelFacade.js~WebGroupState.[WebGroupState.JOINING]",
    "access": "public",
    "description": "Equals to `'JOINING'`.",
    "lineNumber": 30,
    "type": {
      "nullable": null,
      "types": [
        "string"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 15,
    "kind": "get",
    "name": "JOINED",
    "memberof": "src/WebChannelFacade.js~WebGroupState",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/WebChannelFacade.js~WebGroupState.JOINED",
    "access": "public",
    "description": "Joined the group successfully.",
    "lineNumber": 35,
    "type": {
      "nullable": null,
      "types": [
        "number"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 16,
    "kind": "get",
    "name": "[WebGroupState.JOINED]",
    "memberof": "src/WebChannelFacade.js~WebGroupState",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/WebChannelFacade.js~WebGroupState.[WebGroupState.JOINED]",
    "access": "public",
    "description": "Equals to `'JOINED'`.",
    "lineNumber": 40,
    "type": {
      "nullable": null,
      "types": [
        "string"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 17,
    "kind": "get",
    "name": "LEFT",
    "memberof": "src/WebChannelFacade.js~WebGroupState",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/WebChannelFacade.js~WebGroupState.LEFT",
    "access": "public",
    "description": "Left the group. If the connection to the web group has lost other then\nby calling {@link WebGroup#leave} or {@link WebGroup#closeSignaling} methods\nand {@link WebGroup#autoRejoin} is true, then the state would be `LEFT`,\n(usually during a relatively short period) before the rejoining process start.",
    "lineNumber": 48,
    "type": {
      "nullable": null,
      "types": [
        "number"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 18,
    "kind": "get",
    "name": "[WebGroupState.LEFT]",
    "memberof": "src/WebChannelFacade.js~WebGroupState",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/WebChannelFacade.js~WebGroupState.[WebGroupState.LEFT]",
    "access": "public",
    "description": "Equals to `'LEFT'`.",
    "lineNumber": 53,
    "type": {
      "nullable": null,
      "types": [
        "string"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 19,
    "kind": "class",
    "name": "WebGroup",
    "memberof": "src/WebChannelFacade.js",
    "static": true,
    "longname": "src/WebChannelFacade.js~WebGroup",
    "access": "public",
    "export": true,
    "importPath": "netflux/src/WebChannelFacade.js",
    "importStyle": "{WebGroup}",
    "description": "This class is an API starting point. It represents a peer to peer network,\nsimply called a group. Each group member can send/receive broadcast\nas well as personal messages, invite other persons or bots (see {@link WebGroupBotServer}).",
    "examples": [
      "// Create a WebGroup with full mesh topology, autorejoin feature and\n// specified Signaling and ICE servers for WebRTC.\n\nconst wg = new WebGroup({\n  signalingURL: 'wss://mysignaling.com'\n  iceServers: [\n    {\n      urls: 'stun.l.google.com:19302'\n    },\n    {\n      urls: ['turn:myturn.com?transport=udp', 'turn:myturn?transport=tcp'],\n      username: 'user',\n      password: 'password'\n    }\n  ]\n})\n\nwg.onMemberJoin = (id) => {\n  // YOUR CODE...\n}\nwg.onMemberLeave = (id) => {\n  // YOUR CODE...\n}\nwg.onMessage = (id, data, isBroadcast) => {\n  // YOUR CODE...\n}\nwg.onStateChange = (state) => {\n  // YOUR CODE...\n}\nwg.onSignalingStateChange = (state) => {\n  // YOUR CODE...\n}"
    ],
    "lineNumber": 93,
    "interface": false
  },
  {
    "__docId__": 20,
    "kind": "constructor",
    "name": "constructor",
    "memberof": "src/WebChannelFacade.js~WebGroup",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/WebChannelFacade.js~WebGroup#constructor",
    "access": "public",
    "description": "",
    "lineNumber": 101,
    "params": [
      {
        "nullable": null,
        "types": [
          "WebGroupOptions"
        ],
        "spread": false,
        "optional": true,
        "name": "options",
        "description": ""
      },
      {
        "nullable": null,
        "types": [
          "Topology"
        ],
        "spread": false,
        "optional": true,
        "defaultValue": "Topology.FULL_MESH",
        "defaultRaw": "Topology.FULL_MESH",
        "name": "options.topology",
        "description": ""
      },
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": true,
        "defaultValue": "'wss://www.coedit.re:30443'",
        "defaultRaw": "'wss://www.coedit.re:30443'",
        "name": "options.signalingURL",
        "description": ""
      },
      {
        "nullable": null,
        "types": [
          "RTCIceServer[]"
        ],
        "spread": false,
        "optional": true,
        "defaultValue": "[{urls: 'stun:stun3.l.google.com:19302'}]",
        "defaultRaw": "[{urls: 'stun:stun3.l.google.com:19302'}]",
        "name": "options.iceServers",
        "description": ""
      },
      {
        "nullable": null,
        "types": [
          "boolean"
        ],
        "spread": false,
        "optional": true,
        "defaultValue": "true",
        "defaultRaw": true,
        "name": "options.autoRejoin",
        "description": ""
      }
    ]
  },
  {
    "__docId__": 21,
    "kind": "member",
    "name": "id",
    "memberof": "src/WebChannelFacade.js~WebGroup",
    "static": false,
    "longname": "src/WebChannelFacade.js~WebGroup#id",
    "access": "public",
    "description": "The read-only {@link WebGroup} identifier. The same value for all members.",
    "lineNumber": 108,
    "type": {
      "nullable": null,
      "types": [
        "number"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 22,
    "kind": "member",
    "name": "myId",
    "memberof": "src/WebChannelFacade.js~WebGroup",
    "static": false,
    "longname": "src/WebChannelFacade.js~WebGroup#myId",
    "access": "public",
    "description": "The read-only your unique member identifier in the group.",
    "lineNumber": 114,
    "type": {
      "nullable": null,
      "types": [
        "number"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 23,
    "kind": "member",
    "name": "key",
    "memberof": "src/WebChannelFacade.js~WebGroup",
    "static": false,
    "longname": "src/WebChannelFacade.js~WebGroup#key",
    "access": "public",
    "description": "The read-only group session identifier. Equals to an empty string before calling {@link WebGroup#join}.\nDifferent to {@link WebGroup#id}. This key is known and used by Signaling server\nin order to join new members, on the other hand Signaling does not know {@link WebGroup#id}.",
    "lineNumber": 122,
    "type": {
      "nullable": null,
      "types": [
        "string"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 24,
    "kind": "member",
    "name": "members",
    "memberof": "src/WebChannelFacade.js~WebGroup",
    "static": false,
    "longname": "src/WebChannelFacade.js~WebGroup#members",
    "access": "public",
    "description": "The read-only array of all members including yourself (i.e. {@link WebGroup#myId})",
    "lineNumber": 128,
    "type": {
      "nullable": null,
      "types": [
        "number[]"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 25,
    "kind": "member",
    "name": "topology",
    "memberof": "src/WebChannelFacade.js~WebGroup",
    "static": false,
    "longname": "src/WebChannelFacade.js~WebGroup#topology",
    "access": "public",
    "description": "The read-only property which is an enum of type {@link Topology}\nindicating the topology used for this {@link WebGroup} instance.",
    "lineNumber": 135,
    "type": {
      "nullable": null,
      "types": [
        "Topology"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 26,
    "kind": "member",
    "name": "state",
    "memberof": "src/WebChannelFacade.js~WebGroup",
    "static": false,
    "longname": "src/WebChannelFacade.js~WebGroup#state",
    "access": "public",
    "description": "The read-only state of the {@link WebGroup} connection.",
    "lineNumber": 141,
    "type": {
      "nullable": null,
      "types": [
        "WebGroupState"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 27,
    "kind": "member",
    "name": "signalingState",
    "memberof": "src/WebChannelFacade.js~WebGroup",
    "static": false,
    "longname": "src/WebChannelFacade.js~WebGroup#signalingState",
    "access": "public",
    "description": "The read-only state of the signaling server.",
    "lineNumber": 147,
    "type": {
      "nullable": null,
      "types": [
        "SignalingState"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 28,
    "kind": "member",
    "name": "signalingURL",
    "memberof": "src/WebChannelFacade.js~WebGroup",
    "static": false,
    "longname": "src/WebChannelFacade.js~WebGroup#signalingURL",
    "access": "public",
    "description": "The read-only signaling server URL.",
    "lineNumber": 157,
    "type": {
      "nullable": null,
      "types": [
        "string"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 29,
    "kind": "member",
    "name": "autoRejoin",
    "memberof": "src/WebChannelFacade.js~WebGroup",
    "static": false,
    "longname": "src/WebChannelFacade.js~WebGroup#autoRejoin",
    "access": "public",
    "description": "Enable/Desable the auto rejoin feature.",
    "lineNumber": 163,
    "type": {
      "nullable": null,
      "types": [
        "boolean"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 30,
    "kind": "member",
    "name": "onMessage",
    "memberof": "src/WebChannelFacade.js~WebGroup",
    "static": false,
    "longname": "src/WebChannelFacade.js~WebGroup#onMessage",
    "access": "public",
    "description": "This handler is called when a message has been received from the group.\n`id` is an identifier of the member who sent this message.\n`isBroadcast` aquals to true if the data is sent via {@link WebGroup#send}\nand false if sent via {@link WebGroup#sendTo}.",
    "lineNumber": 177,
    "type": {
      "nullable": null,
      "types": [
        "function(id: number, data: DataType, isBroadcast: boolean)"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 31,
    "kind": "member",
    "name": "onMemberJoin",
    "memberof": "src/WebChannelFacade.js~WebGroup",
    "static": false,
    "longname": "src/WebChannelFacade.js~WebGroup#onMemberJoin",
    "access": "public",
    "description": "This handler is called when a new member with `id` as identifier has joined the group.",
    "lineNumber": 195,
    "type": {
      "nullable": null,
      "types": [
        "function(id: number)"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 32,
    "kind": "member",
    "name": "onMemberLeave",
    "memberof": "src/WebChannelFacade.js~WebGroup",
    "static": false,
    "longname": "src/WebChannelFacade.js~WebGroup#onMemberLeave",
    "access": "public",
    "description": "This handler is called when a member with `id` as identifier hes left the group.",
    "lineNumber": 213,
    "type": {
      "nullable": null,
      "types": [
        "function(id: number)"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 33,
    "kind": "member",
    "name": "onStateChange",
    "memberof": "src/WebChannelFacade.js~WebGroup",
    "static": false,
    "longname": "src/WebChannelFacade.js~WebGroup#onStateChange",
    "access": "public",
    "description": "This handler is called when the group state has changed.",
    "lineNumber": 231,
    "type": {
      "nullable": null,
      "types": [
        "function(state: WebGroupState)"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 34,
    "kind": "member",
    "name": "onSignalingStateChange",
    "memberof": "src/WebChannelFacade.js~WebGroup",
    "static": false,
    "longname": "src/WebChannelFacade.js~WebGroup#onSignalingStateChange",
    "access": "public",
    "description": "This handler is called when the signaling state has changed.",
    "lineNumber": 249,
    "type": {
      "nullable": null,
      "types": [
        "function(state: SignalingState)"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 35,
    "kind": "method",
    "name": "join",
    "memberof": "src/WebChannelFacade.js~WebGroup",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/WebChannelFacade.js~WebGroup#join",
    "access": "public",
    "description": "Join the group identified by a key provided by one of the group member.\nIf the current {@link WebGroup#state} value is not {@link WebGroupState#LEFT} or\n{@link WebGroup#signalingState} value is not {@link SignalingState.CLOSED},\nthen do nothing.",
    "lineNumber": 271,
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": true,
        "name": "key",
        "description": "Will be generated if not provided"
      }
    ]
  },
  {
    "__docId__": 36,
    "kind": "method",
    "name": "invite",
    "memberof": "src/WebChannelFacade.js~WebGroup",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/WebChannelFacade.js~WebGroup#invite",
    "access": "public",
    "description": "Invite a bot server to join this group.",
    "lineNumber": 276,
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "url",
        "description": "Bot server URL (See {@link WebGroupBotServerOptions})"
      }
    ]
  },
  {
    "__docId__": 37,
    "kind": "method",
    "name": "closeSignaling",
    "memberof": "src/WebChannelFacade.js~WebGroup",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/WebChannelFacade.js~WebGroup#closeSignaling",
    "access": "public",
    "description": "Close the connection with Signaling server. It fires Signaling state event\nif {@link WebGroup#signalingState} value does not equal to\n{@link SignalingState.CLOSED} already.It may also fire state event only\nif there is no one left in the group.\nvalue does not equal to {@link SignalingState.CLOSED} already.",
    "lineNumber": 284
  },
  {
    "__docId__": 38,
    "kind": "method",
    "name": "leave",
    "memberof": "src/WebChannelFacade.js~WebGroup",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/WebChannelFacade.js~WebGroup#leave",
    "access": "public",
    "description": "Leave the group which means close channels with all members and connection\nwith the Signaling server.",
    "lineNumber": 289
  },
  {
    "__docId__": 39,
    "kind": "method",
    "name": "send",
    "memberof": "src/WebChannelFacade.js~WebGroup",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/WebChannelFacade.js~WebGroup#send",
    "access": "public",
    "description": "Broadcast a message to the group.",
    "lineNumber": 294,
    "params": [
      {
        "nullable": null,
        "types": [
          "DataType"
        ],
        "spread": false,
        "optional": false,
        "name": "data",
        "description": ""
      }
    ]
  },
  {
    "__docId__": 40,
    "kind": "method",
    "name": "sendTo",
    "memberof": "src/WebChannelFacade.js~WebGroup",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/WebChannelFacade.js~WebGroup#sendTo",
    "access": "public",
    "description": "Send a message to a particular group member.",
    "lineNumber": 300,
    "params": [
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "id",
        "description": "Member identifier"
      },
      {
        "nullable": null,
        "types": [
          "DataType"
        ],
        "spread": false,
        "optional": false,
        "name": "data",
        "description": "Message"
      }
    ]
  },
  {
    "__docId__": 41,
    "kind": "method",
    "name": "ping",
    "memberof": "src/WebChannelFacade.js~WebGroup",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/WebChannelFacade.js~WebGroup#ping",
    "access": "public",
    "description": "Get web group latency",
    "lineNumber": 305,
    "return": {
      "nullable": null,
      "types": [
        "Promise<number>"
      ],
      "spread": false,
      "description": "Latency in milliseconds"
    }
  },
  {
    "__docId__": 42,
    "kind": "file",
    "name": "src/index.browser.js",
    "content": "import './misc/polyfills.browser';\nimport { TopologyEnum } from './service/topology/Topology';\nimport { SignalingState as SigState } from './Signaling';\nexport { WebGroup, WebGroupState } from './WebChannelFacade';\nimport { enableLog as debug } from './misc/Util';\n/**\n * Enable/Disable console logs. By default the logs are disabled. Consol logs\n * group and signaling states, connection establishment, disconnection and\n * other useful information for debugging.\n * @param {boolean} value\n */\nexport function enableLog(value) { debug(value); }\n/**\n * The state enum of the signaling server for WebRTC.\n */\nexport class SignalingState {\n    /**\n     * The connection is not yet open.\n     * @type {number}\n     */\n    static get CONNECTING() { return SigState.CONNECTING; }\n    /**\n     * Equals to `'CONNECTING'`.\n     * @type {string}\n     */\n    static get [SignalingState.CONNECTING]() { return SigState[SigState.CONNECTING]; }\n    /**\n     * The connection is open and ready to communicate.\n     * @type {number}\n     */\n    static get OPEN() { return SigState.OPEN; }\n    /**\n     * Equals to `'OPEN'`.\n     * @type {string}\n     */\n    static get [SignalingState.OPEN]() { return SigState[SigState.OPEN]; }\n    /**\n     * `RTCDataChannel` has been established with one of the group member.\n     * From now the signaling is no longer needed, because the joining process\n     * will continue with a help of this member.\n     * @type {number}\n     */\n    static get CONNECTED_WITH_FIRST_MEMBER() { return SigState.CONNECTED_WITH_FIRST_MEMBER; }\n    /**\n     * Equals to `'CONNECTED_WITH_FIRST_MEMBER'`.\n     * @type {string}\n     */\n    static get [SignalingState.CONNECTED_WITH_FIRST_MEMBER]() {\n        return SigState[SigState.CONNECTED_WITH_FIRST_MEMBER];\n    }\n    /**\n     * You has successfully been joined a web group and ready to help join others.\n     * @type {number}\n     */\n    static get READY_TO_JOIN_OTHERS() { return SigState.READY_TO_JOIN_OTHERS; }\n    /**\n     * Equals to `'READY_TO_JOIN_OTHERS'`.\n     * @type {string}\n     */\n    static get [SignalingState.READY_TO_JOIN_OTHERS]() { return SigState[SigState.READY_TO_JOIN_OTHERS]; }\n    /**\n     * The connection is closed.\n     * @type {number}\n     */\n    static get CLOSED() { return SigState.CLOSED; }\n    /**\n     * Equals to `'CLOSED'`.\n     * @type {string}\n     */\n    static get [SignalingState.CLOSED]() { return SigState[SigState.CLOSED]; }\n}\n/**\n * The topology enum.\n */\nexport class Topology {\n    /**\n     * Full mesh topology identifier.\n     * @type {number}\n     */\n    static get FULL_MESH() { return TopologyEnum.FULL_MESH; }\n    /**\n     * Equals to `'FULL_MESH'`.\n     * @type {string}\n     */\n    static get [Topology.FULL_MESH]() { return TopologyEnum[TopologyEnum.FULL_MESH]; }\n}\n/**\n * The options to be passed into {@link WebGroup} constructor.\n * @typedef {Object} WebGroupOptions\n * @property {Topology} [topology] Topology identifier\n * (Full mesh is the only one supported by Netflux for now).\n * @property {string} [signalingURL] Signaling URL for WebRTC.\n * @property {RTCIceServer[]} [iceServers] Array of Ice servers for WebRTC.\n * @property {boolean} [autoRejoin] Whether to automatically rejoin the web group\n * on disconnect or not. Its value may be modified after {@link WebGroup}\n * instantiation at any time.\n */\n/**\n * The options to be passed into {@link WebGroupBotServer} constructor.\n * @typedef {Object} WebGroupBotServerOptions\n * @property {Topology} [topology] See WebGroupOptions.topology\n * @property {string} [signalingURL] See WebGroupOptions.signalingURL\n * @property {RTCIceServer[]} [iceServers] See WebGroupOptions.iceServers\n * @property {boolean} [autoRejoin] See WebGroupOptions.autoRejoin\n * @property {Object} bot Server related options of the bot.\n * @property {NodeJSHttpServer|NodeJSHttpsServer} bot.server NodeJS http(s) server.\n * @property {string} [bot.url] Bot server URL.\n * @property {boolean} [bot.perMessageDeflate] Enable/disable permessage-deflate.\n */\n/**\n * @external {RTCIceServer} https://developer.mozilla.org/en/docs/Web/API/RTCIceServer\n */\n/**\n * @external {Uint8Array} https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Uint8Array\n */\n/**\n * @external {NodeJSHttpServer} https://nodejs.org/api/http.html#http_class_http_server\n */\n/**\n * @external {NodeJSHttpsServer} https://nodejs.org/api/https.html#https_class_https_server\n */\n",
    "static": true,
    "longname": "/home/philippe/workspace/netflux/docs/jsFromTs/src/index.browser.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 43,
    "kind": "function",
    "name": "enableLog",
    "memberof": "src/index.browser.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/index.browser.js~enableLog",
    "access": "public",
    "export": true,
    "importPath": "netflux/src/index.browser.js",
    "importStyle": "{enableLog}",
    "description": "Enable/Disable console logs. By default the logs are disabled. Consol logs\ngroup and signaling states, connection establishment, disconnection and\nother useful information for debugging.",
    "lineNumber": 12,
    "params": [
      {
        "nullable": null,
        "types": [
          "boolean"
        ],
        "spread": false,
        "optional": false,
        "name": "value",
        "description": ""
      }
    ]
  },
  {
    "__docId__": 44,
    "kind": "class",
    "name": "SignalingState",
    "memberof": "src/index.browser.js",
    "static": true,
    "longname": "src/index.browser.js~SignalingState",
    "access": "public",
    "export": true,
    "importPath": "netflux/src/index.browser.js",
    "importStyle": "{SignalingState}",
    "description": "The state enum of the signaling server for WebRTC.",
    "lineNumber": 16,
    "interface": false
  },
  {
    "__docId__": 45,
    "kind": "get",
    "name": "CONNECTING",
    "memberof": "src/index.browser.js~SignalingState",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/index.browser.js~SignalingState.CONNECTING",
    "access": "public",
    "description": "The connection is not yet open.",
    "lineNumber": 21,
    "type": {
      "nullable": null,
      "types": [
        "number"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 46,
    "kind": "get",
    "name": "[SignalingState.CONNECTING]",
    "memberof": "src/index.browser.js~SignalingState",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/index.browser.js~SignalingState.[SignalingState.CONNECTING]",
    "access": "public",
    "description": "Equals to `'CONNECTING'`.",
    "lineNumber": 26,
    "type": {
      "nullable": null,
      "types": [
        "string"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 47,
    "kind": "get",
    "name": "OPEN",
    "memberof": "src/index.browser.js~SignalingState",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/index.browser.js~SignalingState.OPEN",
    "access": "public",
    "description": "The connection is open and ready to communicate.",
    "lineNumber": 31,
    "type": {
      "nullable": null,
      "types": [
        "number"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 48,
    "kind": "get",
    "name": "[SignalingState.OPEN]",
    "memberof": "src/index.browser.js~SignalingState",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/index.browser.js~SignalingState.[SignalingState.OPEN]",
    "access": "public",
    "description": "Equals to `'OPEN'`.",
    "lineNumber": 36,
    "type": {
      "nullable": null,
      "types": [
        "string"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 49,
    "kind": "get",
    "name": "CONNECTED_WITH_FIRST_MEMBER",
    "memberof": "src/index.browser.js~SignalingState",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/index.browser.js~SignalingState.CONNECTED_WITH_FIRST_MEMBER",
    "access": "public",
    "description": "`RTCDataChannel` has been established with one of the group member.\nFrom now the signaling is no longer needed, because the joining process\nwill continue with a help of this member.",
    "lineNumber": 43,
    "type": {
      "nullable": null,
      "types": [
        "number"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 50,
    "kind": "get",
    "name": "[SignalingState.CONNECTED_WITH_FIRST_MEMBER]",
    "memberof": "src/index.browser.js~SignalingState",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/index.browser.js~SignalingState.[SignalingState.CONNECTED_WITH_FIRST_MEMBER]",
    "access": "public",
    "description": "Equals to `'CONNECTED_WITH_FIRST_MEMBER'`.",
    "lineNumber": 48,
    "type": {
      "nullable": null,
      "types": [
        "string"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 51,
    "kind": "get",
    "name": "READY_TO_JOIN_OTHERS",
    "memberof": "src/index.browser.js~SignalingState",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/index.browser.js~SignalingState.READY_TO_JOIN_OTHERS",
    "access": "public",
    "description": "You has successfully been joined a web group and ready to help join others.",
    "lineNumber": 55,
    "type": {
      "nullable": null,
      "types": [
        "number"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 52,
    "kind": "get",
    "name": "[SignalingState.READY_TO_JOIN_OTHERS]",
    "memberof": "src/index.browser.js~SignalingState",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/index.browser.js~SignalingState.[SignalingState.READY_TO_JOIN_OTHERS]",
    "access": "public",
    "description": "Equals to `'READY_TO_JOIN_OTHERS'`.",
    "lineNumber": 60,
    "type": {
      "nullable": null,
      "types": [
        "string"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 53,
    "kind": "get",
    "name": "CLOSED",
    "memberof": "src/index.browser.js~SignalingState",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/index.browser.js~SignalingState.CLOSED",
    "access": "public",
    "description": "The connection is closed.",
    "lineNumber": 65,
    "type": {
      "nullable": null,
      "types": [
        "number"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 54,
    "kind": "get",
    "name": "[SignalingState.CLOSED]",
    "memberof": "src/index.browser.js~SignalingState",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/index.browser.js~SignalingState.[SignalingState.CLOSED]",
    "access": "public",
    "description": "Equals to `'CLOSED'`.",
    "lineNumber": 70,
    "type": {
      "nullable": null,
      "types": [
        "string"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 55,
    "kind": "class",
    "name": "Topology",
    "memberof": "src/index.browser.js",
    "static": true,
    "longname": "src/index.browser.js~Topology",
    "access": "public",
    "export": true,
    "importPath": "netflux/src/index.browser.js",
    "importStyle": "{Topology}",
    "description": "The topology enum.",
    "lineNumber": 75,
    "interface": false
  },
  {
    "__docId__": 56,
    "kind": "typedef",
    "name": "WebGroupOptions",
    "memberof": "src/index.browser.js",
    "static": true,
    "longname": "src/index.browser.js~WebGroupOptions",
    "access": "public",
    "description": "The options to be passed into {@link WebGroup} constructor.",
    "properties": [
      {
        "nullable": null,
        "types": [
          "Topology"
        ],
        "spread": false,
        "optional": true,
        "name": "topology",
        "description": "Topology identifier\n(Full mesh is the only one supported by Netflux for now)."
      },
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": true,
        "name": "signalingURL",
        "description": "Signaling URL for WebRTC."
      },
      {
        "nullable": null,
        "types": [
          "RTCIceServer[]"
        ],
        "spread": false,
        "optional": true,
        "name": "iceServers",
        "description": "Array of Ice servers for WebRTC."
      },
      {
        "nullable": null,
        "types": [
          "boolean"
        ],
        "spread": false,
        "optional": true,
        "name": "autoRejoin",
        "description": "Whether to automatically rejoin the web group\non disconnect or not. Its value may be modified after {@link WebGroup}\ninstantiation at any time."
      }
    ],
    "type": {
      "types": [
        "Object"
      ],
      "optional": false,
      "name": "WebGroupOptions"
    }
  },
  {
    "__docId__": 57,
    "kind": "typedef",
    "name": "WebGroupBotServerOptions",
    "memberof": "src/index.browser.js",
    "static": true,
    "longname": "src/index.browser.js~WebGroupBotServerOptions",
    "access": "public",
    "description": "The options to be passed into {@link WebGroupBotServer} constructor.",
    "properties": [
      {
        "nullable": null,
        "types": [
          "Topology"
        ],
        "spread": false,
        "optional": true,
        "name": "topology",
        "description": "See WebGroupOptions.topology"
      },
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": true,
        "name": "signalingURL",
        "description": "See WebGroupOptions.signalingURL"
      },
      {
        "nullable": null,
        "types": [
          "RTCIceServer[]"
        ],
        "spread": false,
        "optional": true,
        "name": "iceServers",
        "description": "See WebGroupOptions.iceServers"
      },
      {
        "nullable": null,
        "types": [
          "boolean"
        ],
        "spread": false,
        "optional": true,
        "name": "autoRejoin",
        "description": "See WebGroupOptions.autoRejoin"
      },
      {
        "nullable": null,
        "types": [
          "Object"
        ],
        "spread": false,
        "optional": false,
        "name": "bot",
        "description": "Server related options of the bot."
      },
      {
        "nullable": null,
        "types": [
          "NodeJSHttpServer",
          "NodeJSHttpsServer"
        ],
        "spread": false,
        "optional": false,
        "name": "bot.server",
        "description": "NodeJS http(s) server."
      },
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": true,
        "name": "bot.url",
        "description": "Bot server URL."
      },
      {
        "nullable": null,
        "types": [
          "boolean"
        ],
        "spread": false,
        "optional": true,
        "name": "bot.perMessageDeflate",
        "description": "Enable/disable permessage-deflate."
      }
    ],
    "type": {
      "types": [
        "Object"
      ],
      "optional": false,
      "name": "WebGroupBotServerOptions"
    }
  },
  {
    "__docId__": 58,
    "kind": "external",
    "name": "RTCIceServer",
    "externalLink": "https://developer.mozilla.org/en/docs/Web/API/RTCIceServer",
    "memberof": "src/index.browser.js",
    "static": true,
    "longname": "src/index.browser.js~RTCIceServer",
    "access": "public",
    "description": ""
  },
  {
    "__docId__": 59,
    "kind": "external",
    "name": "Uint8Array",
    "externalLink": "https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Uint8Array",
    "memberof": "src/index.browser.js",
    "static": true,
    "longname": "src/index.browser.js~Uint8Array",
    "access": "public",
    "description": ""
  },
  {
    "__docId__": 60,
    "kind": "external",
    "name": "NodeJSHttpServer",
    "externalLink": "https://nodejs.org/api/http.html#http_class_http_server",
    "memberof": "src/index.browser.js",
    "static": true,
    "longname": "src/index.browser.js~NodeJSHttpServer",
    "access": "public",
    "description": ""
  },
  {
    "__docId__": 61,
    "kind": "external",
    "name": "NodeJSHttpsServer",
    "externalLink": "https://nodejs.org/api/https.html#https_class_https_server",
    "memberof": "src/index.browser.js",
    "static": true,
    "longname": "src/index.browser.js~NodeJSHttpsServer",
    "access": "public",
    "description": ""
  },
  {
    "__docId__": 62,
    "kind": "get",
    "name": "FULL_MESH",
    "memberof": "src/index.browser.js~Topology",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/index.browser.js~Topology.FULL_MESH",
    "access": "public",
    "description": "Full mesh topology identifier.",
    "lineNumber": 80,
    "type": {
      "nullable": null,
      "types": [
        "number"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 63,
    "kind": "get",
    "name": "[Topology.FULL_MESH]",
    "memberof": "src/index.browser.js~Topology",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/index.browser.js~Topology.[Topology.FULL_MESH]",
    "access": "public",
    "description": "Equals to `'FULL_MESH'`.",
    "lineNumber": 85,
    "type": {
      "nullable": null,
      "types": [
        "string"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "kind": "index",
    "content": "<p align=\"center\">\n  <a href=\"https://coast-team.github.io/netflux\">\n    <img src=\"manual/asset/logo_cropped.png\" />\n  </a>\n</p>\n\n<p align=\"center\">\n  Universal Javascript <strong style=\"font-weight: bold\">peer to peer</strong> transport API for client and server.<br />\n  Full mesh peer to peer network based on <strong style=\"font-weight: bold\">RTCDataChannel</strong> and <strong style=\"font-weight: bold\">WebSocket</strong>.<br />\n  Send/receive <strong style=\"font-weight: bold\">String</strong> and <strong style=\"font-weight: bold\">Uint8Array</strong> data types.<br />\n  Documentation: https://coast-team.github.io/netflux\n</p>\n\n<p align=\"center\">\n  <a href=\"https://www.npmjs.com/package/netflux\">\n    <img src=\"https://img.shields.io/npm/v/netflux.svg?style=flat-square\" />\n  </a>&nbsp;\n  <a href=\"https://travis-ci.org/coast-team/netflux\">\n    <img src=\"https://travis-ci.org/coast-team/netflux.svg?branch=master\" />\n  </a>\n\n  <br />\n\n  <a href=\"https://www.bithound.io/github/coast-team/netflux\">\n    <img src=\"https://www.bithound.io/github/coast-team/netflux/badges/score.svg\" />\n  </a>&nbsp;\n  <a href=\"https://codeclimate.com/github/coast-team/netflux\">\n    <img src=\"https://codeclimate.com/github/coast-team/netflux/badges/gpa.svg\" />\n  </a>&nbsp;\n  <a href=\"https://coast-team.github.io/netflux\">\n    <img src=\"https://coast-team.github.io/netflux/badge.svg\" />\n  </a>&nbsp;\n  <a href=\"https://codeclimate.com/github/coast-team/netflux/coverage\"><img src=\"https://codeclimate.com/github/coast-team/netflux/badges/coverage.svg\" /></a>\n\n  <br />\n\n  <a href=\"http://commitizen.github.io/cz-cli\">\n    <img src=\"https://img.shields.io/badge/commitizen-friendly-brightgreen.svg?style=flat-square\" />\n  </a>&nbsp;\n  <a href=\"https://github.com/semantic-release/semantic-release\">\n    <img src=\"https://img.shields.io/badge/%20%20%F0%9F%93%A6%F0%9F%9A%80-semantic--release-e10079.svg?style=flat-square\" />\n  </a>&nbsp;\n  <a href=\"https://gitter.im/coast-team/netflux?utm_source=badge&utm_medium=badge&utm_campaign=pr-badge&utm_content=badge\">\n    <img src=\"https://img.shields.io/badge/GITTER-join%20chat-green.svg?style=flat-square\" />\n  </a>\n</p>\n\n<p align=\"center\">\n  <img src=\"manual/asset/example_support.png\" />\n</p>\n\n## Features\n- Universal API (works in Chrome/Firefox and NodeJS).\n- TypeScript declaration files are included.\n- Create peer to peer full mesh network.\n- Send/receive [String][String], [Uint8Array][Uint8Array] data types.\n- Automatic rejoin when the connection with Signaling has lost.\n- Automatic selection between [WebSocket][WebSocket] & [RTCDataChannel][RTCDataChannel].\n- Full control over WebRTC servers: Signaling, STUN and TURN.\n  - Deploy your own Signaling server ([Sigver][Sigver]) or use one provided by default.\n  - Configure STUN and TURN servers.\n- Small Signaling server payload: server is necessary to establish the first connection with\n  one of the group member, then this member acts as a Signaling server to establish connections with the rest of the group members.\n- 3 builds (ES5 code):\n  - `dist/netflux.cjs.js` - CommonJS format for NodeJS (see *package.json#main*)\n  - `dist/esm/index.node.js` - ES module format for NodeJS (see *package.json#module*).\n  - `dist/netflux.umd.js` - UMD format for browsers (see *package.json#browser*).\n\n## Demo\nNetflux is used by our team for Multi User Text Editor ([MUTE repo](https://github.com/coast-team/mute)) development. The demo version is available on: https://www.coedit.re\n\n[WebSocket]: https://developer.mozilla.org/en/docs/Web/API/WebSocket\n[RTCDataChannel]: https://developer.mozilla.org/en/docs/Web/API/RTCDataChannel\n[String]: https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/String\n[Uint8Array]: https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Uint8Array\n[Sigver]: https://github.com/coast-team/sigver\n\n[commitizen]: https://img.shields.io/badge/commitizen-friendly-brightgreen.svg?style=flat-square\n[commitizen-url]: http://commitizen.github.io/cz-cli\n\n[bithound]: https://www.bithound.io/github/coast-team/netflux/badges/score.svg\n[bithound-url]: https://www.bithound.io/github/coast-team/netflux\n\n[codeclimate]: https://codeclimate.com/github/coast-team/netflux/badges/gpa.svg\n[codeclimate-url]: https://codeclimate.com/github/coast-team/netflux\n\n[coverage]: https://codeclimate.com/github/coast-team/netflux/badges/coverage.svg\n[coverage-url]: https://codeclimate.com/github/coast-team/netflux/coverage\n\n[doc]: https://coast-team.github.io/netflux/badge.svg\n[doc-url]: https://coast-team.github.io/netflux/netflux\n",
    "longname": "/home/philippe/workspace/netflux/README.md",
    "name": "./README.md",
    "static": true,
    "access": "public"
  },
  {
    "kind": "manualIndex",
    "globalIndex": true,
    "content": "![Netflux logo][logo]\n\nUniversal Javascript **peer to peer** transport API for client and server.\n\nFull mesh peer to peer network based on **RTCDataChannel** and **WebSocket**.\n\nSend/receive **String** and **Uint8Array** data types.\n\n\n<p align=\"center\">\n  <a href=\"https://www.npmjs.com/package/netflux\">\n    <img src=\"https://img.shields.io/npm/v/netflux.svg?style=flat-square\" />\n  </a>&nbsp;\n  <a href=\"https://travis-ci.org/coast-team/netflux\">\n    <img src=\"https://travis-ci.org/coast-team/netflux.svg?branch=master\" />\n  </a>\n\n  <br />\n\n  <a href=\"https://www.bithound.io/github/coast-team/netflux\">\n    <img src=\"https://www.bithound.io/github/coast-team/netflux/badges/score.svg\" />\n  </a>&nbsp;\n  <a href=\"https://codeclimate.com/github/coast-team/netflux\">\n    <img src=\"https://codeclimate.com/github/coast-team/netflux/badges/gpa.svg\" />\n  </a>&nbsp;\n  <a href=\"https://coast-team.github.io/netflux\">\n    <img src=\"https://coast-team.github.io/netflux/badge.svg\" />\n  </a>&nbsp;\n  <a href=\"https://codeclimate.com/github/coast-team/netflux/coverage\"><img src=\"https://codeclimate.com/github/coast-team/netflux/badges/coverage.svg\" /></a>\n\n  <br />\n\n  <a href=\"http://commitizen.github.io/cz-cli\">\n    <img src=\"https://img.shields.io/badge/commitizen-friendly-brightgreen.svg?style=flat-square\" />\n  </a>&nbsp;\n  <a href=\"https://github.com/semantic-release/semantic-release\">\n    <img src=\"https://img.shields.io/badge/%20%20%F0%9F%93%A6%F0%9F%9A%80-semantic--release-e10079.svg?style=flat-square\" />\n  </a>&nbsp;\n  <a href=\"https://gitter.im/coast-team/netflux?utm_source=badge&utm_medium=badge&utm_campaign=pr-badge&utm_content=badge\">\n    <img src=\"https://img.shields.io/badge/GITTER-join%20chat-green.svg?style=flat-square\" />\n  </a>\n</p>\n\n<p align=\"center\">\n  <img src=\"manual/asset/example_support.png\" />\n</p>\n\n## Features\n- Universal API (works in Chrome/Firefox and NodeJS).\n- TypeScript declaration files are included.\n- Create peer to peer full mesh network.\n- Send/receive [String][String], [Uint8Array][Uint8Array] data types.\n- Automatic rejoin when the connection with Signaling has lost.\n- Automatic selection between [WebSocket][WebSocket] & [RTCDataChannel][RTCDataChannel].\n- Full control over WebRTC servers: Signaling, STUN and TURN.\n  - Deploy your own Signaling server ([Sigver][Sigver]) or use one provided by default.\n  - Configure STUN and TURN servers.\n- Small Signaling server payload: server is necessary to establish the first connection with\n  one of the group member, then this member acts as a Signaling server to establish connections with the rest of the group members.\n- 3 builds (ES5 code):\n  - `dist/netflux.cjs.js` - CommonJS format for NodeJS (see *package.json#main*)\n  - `dist/esm/index.node.js` - ES module format for NodeJS (see *package.json#module*).\n  - `dist/netflux.umd.js` - UMD format for browsers (see *package.json#browser*).\n\n## Demo\nNetflux is used by our team for Multi User Text Editor ([MUTE repo](https://github.com/coast-team/mute)) development. The demo version is available on: https://www.coedit.re\n\n[WebSocket]: https://developer.mozilla.org/en/docs/Web/API/WebSocket\n[RTCDataChannel]: https://developer.mozilla.org/en/docs/Web/API/RTCDataChannel\n[String]: https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/String\n[ArrayBuffer]: https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/ArrayBuffer\n[TypedArray]: https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/TypedArray\n[Sigver]: https://github.com/coast-team/sigver\n\n[commitizen]: https://img.shields.io/badge/commitizen-friendly-brightgreen.svg?style=flat-square\n[commitizen-url]: http://commitizen.github.io/cz-cli\n\n[bithound]: https://www.bithound.io/github/coast-team/netflux/badges/score.svg\n[bithound-url]: https://www.bithound.io/github/coast-team/netflux\n\n[codeclimate]: https://codeclimate.com/github/coast-team/netflux/badges/gpa.svg\n[codeclimate-url]: https://codeclimate.com/github/coast-team/netflux\n\n[coverage]: https://codeclimate.com/github/coast-team/netflux/badges/coverage.svg\n[coverage-url]: https://codeclimate.com/github/coast-team/netflux/coverage\n\n[doc]: https://coast-team.github.io/netflux/badge.svg\n[doc-url]: https://coast-team.github.io/netflux/netflux\n\n[logo]: manual/asset/logo_cropped.png \"Netflux logo\"\n",
    "longname": "/home/philippe/workspace/netflux/manual/index.md",
    "name": "./manual/index.md",
    "static": true,
    "access": "public"
  },
  {
    "kind": "manualAsset",
    "longname": "/home/philippe/workspace/netflux/manual/asset",
    "name": "./manual/asset",
    "static": true,
    "access": "public"
  },
  {
    "kind": "manual",
    "longname": "/home/philippe/workspace/netflux/manual/installation.md",
    "name": "./manual/installation.md",
    "content": "# Installation\n\n## NPM\n```shell\nnpm install -S netflux\n```\nNetflux has an optional peer dependency: `wrtc`. This package provides WebRTC API in NodeJS. It is optional because Netflux can use `WebSocket` instead. For some use cases maybe you still want to connect your server to the peer to peer network via `RTCDataChannel`, then you have to successfully install this dependency, checkout [wrtc repository](https://github.com/js-platform/node-webrtc) then.\n\n\n## What you need\nSignaling server is only mandatory server for Netflux, but for a fully functional peer to peer network (to support all use cases) we also need STUN and TURN servers.\n\nNetflux comes with Signaling and STUN servers by default for easier quickstart. For TURN server two solutions are possible: either deploy your own or rent one at [Xirsys](https://xirsys.com/) for example or any other similar services.\n\n\n### Signaling server\n**Default**: `wss://www.coedit.re:20443`\n\nWe developed a Signaling server: [Sigver](https://github.com/coast-team/sigver). It is the only signaling server (signaling mechanism) which is supported by Netflux for now.\n\n**TIP**: we recommend to deploy your own instance of Sigver for production.\n\n### STUN server\n**Default**: `stun:stun3.l.google.com:19302`\n\nThere many other free STUN servers available in the Web.\n\n### TURN server\nNo free TURN server available in the Web. Checkout [Xirsys](https://xirsys.com/) to rent one or deploy your own.\n\n## How to deploy STUN/TURN servers\n\nThis guide present a basic configuration for [coturn](https://github.com/coturn/coturn).\nIt allow us to deploy our own STUN/TURN server in order to connect users behind a NAT or Firewall.\n\nFor more informations or options, see coturn [documentation](https://github.com/coturn/coturn/wiki/README).\n\nOn most Linux Distribution, the package is in the repo:\n`apt-get install coturn`\n\nYou must have SQLite installed:\n`sudo apt-get install sqlite3 libsqlite3-dev`\n\nConfig file can be found at:\n`/etc/turnserver.conf`\n\nSimple config file should look like this:\n```bash\n# you can listen ports 3478 and 5349 instead of 80/443\nlistening-port=80\ntls-listening-port=443\n\nlistening-ip=your-ip-address\n\nrelay-ip=your-ip-address\nexternal-ip=your-ip-address\n\nrealm=yourdomain.com\nserver-name=yourdomain.com\n\n# webRTC authentication method\nlt-cred-mech\n\n# Database location\nuserdb=/var/lib/turn/turndb\n\n# Add ssl certificate for your server\ncert=/etc/ssl/certificate.pem\npkey=/etc/ssl/private.key\n\nno-stdout-log\n```\n\nIf you don't have any SSL certificate, you may use [Let's Encrypt](https://letsencrypt.org/).\n\nCreate a user in order to access your Turn server:\n`turnadmin -a -u userName -p password -r yourdomain.com`\n\nLaunch your server:\n`turnserver`\nor in daemon:\n`turnserver -o`\n\nVerify that your server is up and running with [Trickle ICE](https://webrtc.github.io/samples/src/content/peerconnection/trickle-ice/).\n",
    "static": true,
    "access": "public"
  },
  {
    "kind": "manual",
    "longname": "/home/philippe/workspace/netflux/manual/usage.md",
    "name": "./manual/usage.md",
    "content": "# Usage\nThere are 4 builds (all ES5 code):\n- `dist/netflux.cjs.js` CommonJS format for NodeJS.\n- `dist/netflux.node.esm.js` ECMAScript 6 module format for NodeJS.\n- `dist/netflux.browser.esm.js` ECMAScript 6 module format for browsers.\n- `dist/netflux.umd.js` UMD format for browsers.\n\nThe `package.json` contains the following fields:\n```json\n...\n\"main\": \"dist/netflux.cjs.js\",\n\"module\": \"dist/esm/index.node.js\",\n\"browser\": \"dist/netflux.umd.js\",\n...\n```\n\nAll builds are either for NodeJS or for Browser environment.\n\n**For browser environment** exported members are:\n- `WebGroup`\n- `WebGroupState` enum\n- `SignalingState` enum\n- `Topology` enum\n- `DataType` type\n- `WebGroupOption` type\n\n**For NodeJS environment** exported members are the same as for browser plus:\n- `WebGroupBotServer`\n- `WebGroupBotServerOptions` type.\n\n## CommonJS: netflux.cjs.js\n`dist/netflux.cjs.js` - CommonJS format, built for NodeJS.\n\n```Javascript\n// NodeJS\nconst netflux = require('netflux')\nvar wg = new netflux.WebGroup()\n```\n\n## ES module: esm/index.node.js\n\n`esm/index.node.js` is suitable for Webpack, Browserify or any alike, which also undersand `package.json#module` property. It is build for NodeJS: contains all exported API members and all necessary polyfills for NodeJS environment.\n\n```javascript\nexport {WebGroup, WebGroupState, WebGroupBotServer, WebGroupBotServerOptions} from 'netflux'\nconst wg = new WebGroup()\n```\n\n## UMD\n`dist/netflux.umd.js` - Universal Module Definition format is compatible with AMD, CommonJS and \"global\" modules. Built for browser and suitable for Webpack, Browserify and any other who\nalso understands `package.json#browser` property.\n\n```html\n<!-- Browser global usage example -->\n<script src=\"netflux.es5.umd.js\">\n  window.netflux !== undefined // true\n  var wg = new window.netflux.WebGroup()\n</script>\n```\n\n## Configuration\nFor a `WebGroup` object all options are optional.\n```javascript\n// Example:\nconst wg = new WebGroup({\n  signalingURL: 'MY_SIGNALING_URL',\n  iceServers: [\n    {\n      urls: 'stun.l.google.com:19302'\n    },\n    {\n      urls: ['turn:myturn.com?transport=udp', 'turn:myturn?transport=tcp'],\n      username: 'user',\n      password: 'password'\n    }\n  ]\n})\n```\n\nFor `WebGroupBotServer` the server option is mandatory.\n```javascript\n// Example:\nconst http = require('http')\nconst myServer = http.createServer()\nconst wg = new WebGroupBotServer({\n  server: myServer,\n  signalingURL: 'MY_SIGNALING_URL',\n  webGroupOptions: {\n    iceServers: [\n      {\n        urls: 'stun.l.google.com:19302'\n      },\n      {\n        urls: ['turn:myturn.com?transport=udp', 'turn:myturn?transport=tcp'],\n        username: 'user',\n        password: 'password'\n      }\n    ]\n  }\n})\n```\n",
    "static": true,
    "access": "public"
  },
  {
    "kind": "manual",
    "longname": "/home/philippe/workspace/netflux/manual/bestpractices.md",
    "name": "./manual/bestpractices.md",
    "content": "# Best practices\nThe behavior of Chrome and Firefox on Linux/MacOS (likely on Windows also, but not tested) concerning holding JS execution, [Online/Offline](https://developer.mozilla.org/en/docs/Online_and_offline_events) and [Page Visibility](https://developer.mozilla.org/en/docs/Web/API/Page_Visibility_API) APIs maybe different when OS goes into sleep mode and resumes from it. That why the practices listed here might be useful for these scenarios and not only.\n\n## Leave WebGroup before Browser/Tab close\nClean leave is always preferable. Other members will be notified immediately.\n```Javascript\n// \"webGroup\" variable has been defined earlier.\nwindow.addEventListener('beforeunload', () => {\n    webGroup.leave()\n})\n```\n## Listen on Online/Offline events\nMaybe useful to not rejoin a web group if the client is offline anyway. Checkout [Online/Offline API doc](https://developer.mozilla.org/en/docs/Online_and_offline_events) for more details and to understand what *Online* actually means.\n\n```Javascript\n// \"webGroup\" variable has been defined earlier.\n\nwindow.addEventListener('offline', () => {\n    // You are offline, then leave the web group\n    webGroup.leave()\n})\nwindow.addEventListener('online', () => {\n    // You are online again, try to rejoin if necessary.\n    webGroup.join()\n})\n```\n\n**Remark**: It was noticed for Chrome browser on some operating systems that when the OS resumes from a sleep mode, the *Offline*/*Online* events fired twice in a very short period of time, this may cause a problem for Netflux to rejoin, so consider to do something like:\n\n```Javascript\n// \"webGroup\" variable has been defined earlier.\n\nlet timer\nwindow.addEventListener('online', () => {\n  if (timer !== undefined) {\n    timer = setTimeout(() => {\n      webGroup.join()\n      timer = undefined\n    }, 500)\n  }\n})\n```\n\n## Page Visibility API might be useful in some scenarios\nIt was noticed that when MacOS goes into sleep mode, Chrome and Firefox do not stop JS execution, but close WebRTC connections and do not allow to create new. However the WebSocket connection is maintained. This cause problem as you are no longer connected to other peers, but the connection with Signaling server is still alive. For this reason it might be useful to do something like (checkout [Page Visibility API doc](https://developer.mozilla.org/en/docs/Web/API/Page_Visibility_API)):\n\n```Javascript\n// \"webGroup\" variable has been defined earlier.\n\nwebGroup.onMemberLeave = () => {\n  if (webGroup.members.length === 0 && window.document.visibilityState === 'hidden') {\n    webGroup.leave()\n  }\n}\n\nwindow.addEventListener('visibilitychange', () => {\n  if (window.navigator.onLine &&\n      window.document.visibilityState === 'visible' &&\n      webGroup.state === WebGroupState.LEFT\n  ) {\n    webGroup.join()\n  }\n})\n```\n",
    "static": true,
    "access": "public"
  },
  {
    "kind": "manual",
    "longname": "/home/philippe/workspace/netflux/manual/faq.md",
    "name": "./manual/faq.md",
    "content": "# FAQ\n\n#### **How `RTCDataChannel` and `WebSocket` are used?**\n\nNetflux can create a peer to peer network with the following connection types:\n - `RTCDataChannel` (WebRTC)\n - `WebSocket`\n\n`RTCDataChannel` connection could be established between:\n - Browser & Browser\n - Browser & Server (If server supports)\n - Server & Server (If both servers support)\n\nOn the other hand, a `WebSocket` could be created only between:\n - Browser & Server\n - Server & Server\n",
    "static": true,
    "access": "public"
  },
  {
    "__docId__": 64,
    "kind": "testFile",
    "name": "test/functional/1member.test.js",
    "content": "/// <reference types='jasmine' />\nimport { SignalingState, Topology, WebGroup, WebGroupState } from '../../src/index.browser';\nimport { MAX_KEY_LENGTH } from '../../src/misc/Util';\nimport { SIGNALING_URL } from '../util/helper';\n/** @test {WebGroup} */\ndescribe('Alone', () => {\n    /** @test {WebGroup#constructor} */\n    it('constructor', () => {\n        const wg = new WebGroup({ signalingURL: SIGNALING_URL });\n        // Check members\n        expect(typeof wg.id).toBe('number');\n        expect(Reflect.getOwnPropertyDescriptor(wg, 'id').set).toBeUndefined();\n        expect(typeof wg.myId).toBe('number');\n        expect(Reflect.getOwnPropertyDescriptor(wg, 'myId').set).toBeUndefined();\n        expect(wg.key).toBe('');\n        expect(Reflect.getOwnPropertyDescriptor(wg, 'key').set).toBeUndefined();\n        expect(wg.members).toEqual([wg.myId]);\n        expect(Reflect.getOwnPropertyDescriptor(wg, 'members').set).toBeUndefined();\n        expect(wg.topology).toBe(Topology.FULL_MESH);\n        expect(Reflect.getOwnPropertyDescriptor(wg, 'topology').set).toBeUndefined();\n        expect(wg.state).toBe(WebGroupState.LEFT);\n        expect(Reflect.getOwnPropertyDescriptor(wg, 'state').set).toBeUndefined();\n        expect(wg.signalingState).toBe(SignalingState.CLOSED);\n        expect(Reflect.getOwnPropertyDescriptor(wg, 'signalingState').set).toBeUndefined();\n        expect(wg.signalingURL).toBe(SIGNALING_URL);\n        expect(Reflect.getOwnPropertyDescriptor(wg, 'signalingURL').set).toBeUndefined();\n        expect(wg.autoRejoin).toBeTruthy();\n        wg.autoRejoin = false;\n        expect(wg.autoRejoin).toBeFalsy();\n        // Check event handlers\n        expect(wg.onMemberJoin).toBeUndefined();\n        expect(wg.onMemberLeave).toBeUndefined();\n        expect(wg.onMessage).toBeUndefined();\n        expect(wg.onStateChange).toBeUndefined();\n        expect(wg.onSignalingStateChange).toBeUndefined();\n        // Check methods\n        expect(typeof wg.join).toBe('function');\n        expect(typeof wg.invite).toBe('function');\n        expect(typeof wg.closeSignaling).toBe('function');\n        expect(typeof wg.leave).toBe('function');\n        expect(typeof wg.send).toBe('function');\n        expect(typeof wg.sendTo).toBe('function');\n        expect(typeof wg.ping).toBe('function');\n    });\n    /** @test {WebGroup#join} */\n    describe('join', () => {\n        let wg;\n        beforeEach(() => wg = new WebGroup({ signalingURL: SIGNALING_URL }));\n        // afterEach (() => wg.leave())\n        function expectToJoin(key) {\n            return new Promise((resolve, reject) => {\n                const oldMyId = wg.myId;\n                const oldId = wg.id;\n                wg.onMessage = () => fail('onMessage called');\n                wg.onMemberJoin = () => fail('onMemberJoin called');\n                wg.onMemberLeave = () => fail('onMemberLeave called');\n                let firstStateDone = false;\n                function resolveCheck() {\n                    if (firstStateDone) {\n                        expect(wg.myId).toBe(oldMyId);\n                        expect(wg.id).toBe(oldId);\n                        expect(typeof wg.key).toBe('string');\n                        expect(wg.members).toEqual([wg.myId]);\n                        expect(wg.topology).toBe(Topology.FULL_MESH);\n                        expect(wg.state).toBe(WebGroupState.JOINED);\n                        expect(wg.signalingState).toBe(SignalingState.READY_TO_JOIN_OTHERS);\n                        expect(wg.signalingURL).toBe(SIGNALING_URL);\n                        expect(wg.autoRejoin).toBeTruthy();\n                        setTimeout(() => {\n                            expect(wg.state).toBe(WebGroupState.JOINED);\n                            expect(wg.signalingState).toBe(SignalingState.READY_TO_JOIN_OTHERS);\n                            resolve();\n                        }, 100);\n                    }\n                    else {\n                        firstStateDone = true;\n                    }\n                }\n                const onStateChangeGen = (function* () {\n                    let state = yield;\n                    expect(state).toEqual(WebGroupState.JOINING);\n                    expect(wg.state).toBe(state);\n                    state = yield;\n                    expect(state).toEqual(WebGroupState.JOINED);\n                    expect(wg.state).toBe(state);\n                    resolveCheck();\n                })();\n                onStateChangeGen.next();\n                const onSignalingStateChangeGen = (function* () {\n                    let state = yield;\n                    expect(state).toEqual(SignalingState.CONNECTING);\n                    expect(wg.signalingState).toBe(state);\n                    state = yield;\n                    expect(state).toEqual(SignalingState.OPEN);\n                    expect(wg.signalingState).toBe(state);\n                    state = yield;\n                    expect(state).toEqual(SignalingState.READY_TO_JOIN_OTHERS);\n                    expect(wg.signalingState).toBe(state);\n                    resolveCheck();\n                })();\n                onSignalingStateChangeGen.next();\n                wg.onStateChange = (state) => onStateChangeGen.next(state);\n                wg.onSignalingStateChange = (state) => onSignalingStateChangeGen.next(state);\n                try {\n                    wg.join();\n                }\n                catch (err) {\n                    reject(err);\n                }\n            });\n        }\n        /** @test {WebGroup#join} */\n        it('should join without a provided key', (done) => {\n            expectToJoin().then(() => {\n                expect(wg.key).not.toBe('');\n                done();\n            })\n                .catch((err) => fail(err));\n        });\n        /** @test {WebGroup#join} */\n        it('should join with a provided key', (done) => {\n            const key = `Free from desire, you realize the mystery.\n        Caught in desire, you see only the manifestations. (Tao Te Ching)`;\n            expectToJoin(key).then(() => {\n                expect(wg.key).not.toBe(key);\n                done();\n            })\n                .catch((err) => fail(err));\n        });\n        function expectToThrowErrorWhenJoin(webGroup, key, errMessage) {\n            webGroup.onStateChange = () => fail('onStateChange called');\n            webGroup.onSignalingStateChange = () => fail('onSignalingStateChange called');\n            webGroup.onMessage = () => fail('onMessage called');\n            webGroup.onMemberJoin = () => fail('onMemberJoin called');\n            webGroup.onMemberLeave = () => fail('onMemberLeave called');\n            expect(() => webGroup.join(key)).toThrowError(errMessage);\n            expect(webGroup.key).toBe('');\n            expect(webGroup.members).toEqual([webGroup.myId]);\n            expect(webGroup.topology).toBe(Topology.FULL_MESH);\n            expect(webGroup.state).toBe(WebGroupState.LEFT);\n            expect(webGroup.signalingState).toBe(SignalingState.CLOSED);\n            expect(webGroup.signalingURL).toBe(SIGNALING_URL);\n            expect(webGroup.autoRejoin).toBeTruthy();\n            expect(webGroup.state).toBe(WebGroupState.LEFT);\n            expect(webGroup.key).toBe('');\n        }\n        /** @test {WebGroup#join} */\n        it('should throw an error, because the key is not a \"string\"', () => {\n            const oldMyId = wg.myId;\n            const oldId = wg.id;\n            const key = 42;\n            expectToThrowErrorWhenJoin(wg, key, 'Failed to join: the key type \"number\" is not a \"string\"');\n            expect(wg.myId).toBe(oldMyId);\n            expect(wg.id).toBe(oldId);\n        });\n        /** @test {WebGroup#join} */\n        it('should throw an error, because the key is an empty string', () => {\n            const oldMyId = wg.myId;\n            const oldId = wg.id;\n            const key = '';\n            expectToThrowErrorWhenJoin(wg, key, 'Failed to join: the key is an empty string');\n            expect(wg.myId).toBe(oldMyId);\n            expect(wg.id).toBe(oldId);\n        });\n        /** @test {WebGroup#join} */\n        it('should throw an error, because the key length is too long', () => {\n            const oldMyId = wg.myId;\n            const oldId = wg.id;\n            const key = `\n        PAYING DOUBLE FOR CAMELS\n        A camel dealer reached a village to sell fine animals at a very good price.\n        Everyone bought one, except Mr. Hoosep.\n\n        Some time later, the village received a visit from another dealer, with\n        excellent camels, but they were much more expensive. This time, Hoosep\n        bought some animals.\n\n        \"You did not buy the camels when they were almost for free, and now you\n        pay almost double,\" criticized his friends.\n\n        \"Those cheap ones were very expensive for me, because at that time I had\n        very little money,\" answered Hoosep, \"these animals might seem more\n        expensive, but for me they are cheap, because I have more than enough to\n        buy them.\" (Paulo Coelho)\n      `;\n            expectToThrowErrorWhenJoin(wg, key, `Failed to join : the key length of ${key.length} exceeds the maximum of ${MAX_KEY_LENGTH} characters`);\n            expect(wg.myId).toBe(oldMyId);\n            expect(wg.id).toBe(oldId);\n        });\n    });\n    /** @test {WebGroup#closeSignaling} */\n    describe('closeSignaling', () => {\n        let wg;\n        beforeEach(() => wg = new WebGroup({ signalingURL: SIGNALING_URL }));\n        // afterEach (() => wg.leave())\n        /** @test {WebGroup#closeSignaling} */\n        it('should do nothing', (done) => {\n            const oldId = wg.id;\n            const oldMyId = wg.myId;\n            wg.onStateChange = () => fail('onStateChange called');\n            wg.onSignalingStateChange = () => fail('onSignalingStateChange called');\n            wg.onMessage = () => fail('onMessage called');\n            wg.onMemberJoin = () => fail('onMemberJoin called');\n            wg.onMemberLeave = () => fail('onMemberLeave called');\n            wg.closeSignaling();\n            setTimeout(() => {\n                expect(wg.myId).toBe(oldMyId);\n                expect(wg.id).toBe(oldId);\n                expect(wg.key).toBe('');\n                expect(wg.members).toEqual([wg.myId]);\n                expect(wg.topology).toBe(Topology.FULL_MESH);\n                expect(wg.state).toBe(WebGroupState.LEFT);\n                expect(wg.signalingState).toBe(SignalingState.CLOSED);\n                expect(wg.signalingURL).toBe(SIGNALING_URL);\n                expect(wg.autoRejoin).toBeTruthy();\n                done();\n            }, 100);\n        });\n        /** @test {WebGroup#closeSignaling} */\n        it('should close the connection with Signaling server and leave the group after calling join', (done) => {\n            const oldId = wg.id;\n            const oldMyId = wg.myId;\n            wg.onStateChange = (state) => {\n                if (state === WebGroupState.JOINED) {\n                    setTimeout(() => {\n                        wg.onStateChange = (s) => expect(s).toBe(WebGroupState.LEFT);\n                        wg.onSignalingStateChange = (s) => expect(s).toBe(SignalingState.CLOSED);\n                        wg.onMessage = () => fail('onMessage called');\n                        wg.onMemberJoin = () => fail('onMemberJoin called');\n                        wg.onMemberLeave = () => fail('onMemberLeave called');\n                        wg.closeSignaling();\n                        setTimeout(() => {\n                            expect(wg.myId).toBe(oldMyId);\n                            expect(wg.id).toBe(oldId);\n                            expect(wg.key).toBe('');\n                            expect(wg.members).toEqual([wg.myId]);\n                            expect(wg.topology).toBe(Topology.FULL_MESH);\n                            expect(wg.state).toBe(WebGroupState.LEFT);\n                            expect(wg.signalingState).toBe(SignalingState.CLOSED);\n                            expect(wg.signalingURL).toBe(SIGNALING_URL);\n                            expect(wg.autoRejoin).toBeTruthy();\n                            done();\n                        }, 100);\n                    }, 100);\n                }\n            };\n            wg.join();\n        });\n    });\n});\n",
    "static": true,
    "longname": "/home/philippe/workspace/netflux/docs/jsFromTs/test/functional/1member.test.js",
    "access": null,
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 65,
    "kind": "test",
    "name": "describe0",
    "testId": 0,
    "memberof": "test/functional/1member.test.js",
    "testDepth": 0,
    "static": true,
    "longname": "test/functional/1member.test.js~describe0",
    "access": null,
    "description": "Alone",
    "lineNumber": 6,
    "testTargets": [
      "WebGroup"
    ]
  },
  {
    "__docId__": 66,
    "kind": "test",
    "name": "it1",
    "testId": 1,
    "memberof": "test/functional/1member.test.js~describe0",
    "testDepth": 1,
    "static": true,
    "longname": "test/functional/1member.test.js~describe0.it1",
    "access": null,
    "description": "constructor",
    "lineNumber": 8,
    "testTargets": [
      "WebGroup#constructor"
    ]
  },
  {
    "__docId__": 67,
    "kind": "test",
    "name": "describe2",
    "testId": 2,
    "memberof": "test/functional/1member.test.js~describe0",
    "testDepth": 1,
    "static": true,
    "longname": "test/functional/1member.test.js~describe0.describe2",
    "access": null,
    "description": "join",
    "lineNumber": 46,
    "testTargets": [
      "WebGroup#join"
    ]
  },
  {
    "__docId__": 68,
    "kind": "test",
    "name": "it3",
    "testId": 3,
    "memberof": "test/functional/1member.test.js~describe0.describe2",
    "testDepth": 2,
    "static": true,
    "longname": "test/functional/1member.test.js~describe0.describe2.it3",
    "access": null,
    "description": "should join without a provided key",
    "lineNumber": 113,
    "testTargets": [
      "WebGroup#join"
    ]
  },
  {
    "__docId__": 69,
    "kind": "test",
    "name": "it4",
    "testId": 4,
    "memberof": "test/functional/1member.test.js~describe0.describe2",
    "testDepth": 2,
    "static": true,
    "longname": "test/functional/1member.test.js~describe0.describe2.it4",
    "access": null,
    "description": "should join with a provided key",
    "lineNumber": 121,
    "testTargets": [
      "WebGroup#join"
    ]
  },
  {
    "__docId__": 70,
    "kind": "test",
    "name": "it5",
    "testId": 5,
    "memberof": "test/functional/1member.test.js~describe0.describe2",
    "testDepth": 2,
    "static": true,
    "longname": "test/functional/1member.test.js~describe0.describe2.it5",
    "access": null,
    "description": "should throw an error, because the key is not a \"string\"",
    "lineNumber": 148,
    "testTargets": [
      "WebGroup#join"
    ]
  },
  {
    "__docId__": 71,
    "kind": "test",
    "name": "it6",
    "testId": 6,
    "memberof": "test/functional/1member.test.js~describe0.describe2",
    "testDepth": 2,
    "static": true,
    "longname": "test/functional/1member.test.js~describe0.describe2.it6",
    "access": null,
    "description": "should throw an error, because the key is an empty string",
    "lineNumber": 157,
    "testTargets": [
      "WebGroup#join"
    ]
  },
  {
    "__docId__": 72,
    "kind": "test",
    "name": "it7",
    "testId": 7,
    "memberof": "test/functional/1member.test.js~describe0.describe2",
    "testDepth": 2,
    "static": true,
    "longname": "test/functional/1member.test.js~describe0.describe2.it7",
    "access": null,
    "description": "should throw an error, because the key length is too long",
    "lineNumber": 166,
    "testTargets": [
      "WebGroup#join"
    ]
  },
  {
    "__docId__": 73,
    "kind": "test",
    "name": "describe8",
    "testId": 8,
    "memberof": "test/functional/1member.test.js~describe0",
    "testDepth": 1,
    "static": true,
    "longname": "test/functional/1member.test.js~describe0.describe8",
    "access": null,
    "description": "closeSignaling",
    "lineNumber": 192,
    "testTargets": [
      "WebGroup#closeSignaling"
    ]
  },
  {
    "__docId__": 74,
    "kind": "test",
    "name": "it9",
    "testId": 9,
    "memberof": "test/functional/1member.test.js~describe0.describe8",
    "testDepth": 2,
    "static": true,
    "longname": "test/functional/1member.test.js~describe0.describe8.it9",
    "access": null,
    "description": "should do nothing",
    "lineNumber": 197,
    "testTargets": [
      "WebGroup#closeSignaling"
    ]
  },
  {
    "__docId__": 75,
    "kind": "test",
    "name": "it10",
    "testId": 10,
    "memberof": "test/functional/1member.test.js~describe0.describe8",
    "testDepth": 2,
    "static": true,
    "longname": "test/functional/1member.test.js~describe0.describe8.it10",
    "access": null,
    "description": "should close the connection with Signaling server and leave the group after calling join",
    "lineNumber": 220,
    "testTargets": [
      "WebGroup#closeSignaling"
    ]
  },
  {
    "__docId__": 76,
    "kind": "testFile",
    "name": "test/functional/manyMembers.test.js",
    "content": "/// <reference types='jasmine' />\nimport { Subject } from 'rxjs/Subject';\nimport { WebGroupState } from '../../src/index.browser';\nimport * as helper from '../util/helper';\nconst USE_CASES = [2, 3, 7];\nconst scenarios = [\n    new helper.Scenario('cc'),\n    new helper.Scenario('cb'),\n    new helper.Scenario('ccc'),\n    new helper.Scenario('ccb'),\n    new helper.Scenario('ccccccc'),\n    new helper.Scenario('cccbccc'),\n];\nconst PEER_FACE = '🙂 ';\nconst faces = (length) => {\n    let res = PEER_FACE;\n    for (let i = 1; i < length; i++) {\n        res += '🙂 ';\n    }\n    return res;\n};\n/** @test {WebGroup} */\ndescribe('Many members', () => {\n    /** @test {WebGroup#join} */\n    describe('should join', () => {\n        let wgs;\n        afterEach(() => wgs.forEach((wg) => wg.leave()));\n        scenarios.forEach((scenario) => {\n            it(`${scenario.smiles}`, (done) => {\n                const network = new Subject();\n                let nextJoiningIndex = 0;\n                let botJoined = false;\n                const key = helper.randKey();\n                wgs = helper.createWebGroups(scenario.nbBrowsers);\n                wgs.forEach((wg, index) => {\n                    expect(wg.state).toBe(WebGroupState.LEFT);\n                    wg.onMemberJoinCalledTimes = 0;\n                    wg.onMemberJoin = (id) => {\n                        wg.onMemberJoinCalledTimes++;\n                        // Joined peer's id should be among WebGroup members ids\n                        expect(wg.members.includes(id)).toBeTruthy();\n                        // Its id should be included only ONCE\n                        expect(wg.members.indexOf(id)).toEqual(wg.members.lastIndexOf(id));\n                    };\n                    wg.onStateChangeCalledTimes = 0;\n                    wg.onStateChange = (state) => {\n                        wg.onStateChangeCalledTimes++;\n                        if (state === WebGroupState.JOINED) {\n                            network.next({ wg, isBot: false });\n                        }\n                    };\n                });\n                network.subscribe(({ wg, isBot }) => {\n                    nextJoiningIndex = isBot ? nextJoiningIndex : nextJoiningIndex + 1;\n                    if ((nextJoiningIndex === scenario.nbBrowsers && !scenario.hasBot()) ||\n                        (nextJoiningIndex === scenario.nbBrowsers && scenario.hasBot() && botJoined)) {\n                        network.complete();\n                    }\n                    else if (nextJoiningIndex === scenario.botIndex && !isBot) {\n                        wg.invite(helper.BOT_URL);\n                        helper.botWaitJoin(wgs[0].id)\n                            .then(() => {\n                            botJoined = true;\n                            network.next({ isBot: true });\n                        });\n                    }\n                    else {\n                        wgs[nextJoiningIndex].join(key);\n                    }\n                }, (err) => { }, () => {\n                    let botCheck = Promise.resolve();\n                    if (scenario.hasBot()) {\n                        botCheck = helper.expectBotMembers(wgs[0].id, wgs, scenario.nbMembers);\n                    }\n                    botCheck.then(() => {\n                        helper.expectMembers(wgs, scenario.nbMembers);\n                        wgs.forEach((wg) => {\n                            expect(wg.state).toBe(WebGroupState.JOINED);\n                            expect(wg.onMemberJoinCalledTimes).toBe(scenario.nbMembers - 1);\n                            expect(wg.onStateChangeCalledTimes).toBe(2);\n                        });\n                        done();\n                    })\n                        .catch(done.fail);\n                });\n                wgs[0].join(key);\n            }, scenario.nbMembers * 2000);\n        });\n    });\n    /** @test {WebGroup#ping} */\n    describe('Should ping', () => {\n        let wgs;\n        afterEach(() => wgs.forEach((wg) => wg.leave()));\n        USE_CASES.forEach((numberOfPeers) => {\n            it(`${numberOfPeers}`, (done) => {\n                helper.createAndConnectWebGroups(numberOfPeers)\n                    .then((webChannels) => (wgs = webChannels))\n                    .then(() => wgs.map((wg) => wg.ping().then((p) => expect(Number.isInteger(p)).toBeTruthy())))\n                    .then((proms) => Promise.all(proms))\n                    .then(done)\n                    .catch(done.fail);\n            });\n        });\n    });\n    describe('Should send/receive', () => {\n        let wgs;\n        afterEach(() => wgs.forEach((wg) => wg.leave()));\n        USE_CASES.forEach((numberOfPeers) => {\n            /** @test {WebGroup#sendTo} */\n            describe(`${faces(numberOfPeers)}`, () => {\n                it(`private: ArrayBuffer, String & 50Kb chunk`, (done) => {\n                    helper.createAndConnectWebGroups(numberOfPeers)\n                        .then((webChannels) => (wgs = webChannels))\n                        .then(() => helper.sendAndExpectOnMessage(wgs, false))\n                        .then(done)\n                        .catch(done.fail);\n                });\n                /** @test {WebGroup#send} */\n                it(`broadcast: ArrayBuffer, String & 50Kb chunk`, (done) => {\n                    helper.createAndConnectWebGroups(numberOfPeers)\n                        .then((webChannels) => (wgs = webChannels))\n                        .then(() => helper.sendAndExpectOnMessage(wgs, true))\n                        .then(done)\n                        .catch(done.fail);\n                });\n            });\n        });\n    });\n    describe(`${PEER_FACE}${PEER_FACE}`, () => {\n        let wgs;\n        afterEach(() => wgs.forEach((wg) => wg.leave()));\n        /** @test {WebGroup#sendTo} */\n        helper.itBrowser(true, 'should send/receive ~4 MB string', (done) => {\n            const str = helper.randStr();\n            helper.createAndConnectWebGroups(2)\n                .then((webChannels) => (wgs = webChannels))\n                .then(() => {\n                wgs[0].onMessage = (id, msg) => {\n                    expect(id).toEqual(wgs[1].myId);\n                    expect(msg === str).toBeTruthy();\n                    done();\n                };\n                wgs[1].sendTo(wgs[0].myId, str);\n            });\n        }, 10000);\n    });\n    /** @test {WebGroup#leave} */\n    describe('Should leave', () => {\n        let wgs;\n        afterEach(() => wgs.forEach((wg) => wg.leave()));\n        USE_CASES.forEach((numberOfPeers) => {\n            it(`${faces(numberOfPeers)}`, (done) => {\n                helper.createAndConnectWebGroups(numberOfPeers)\n                    .then((webChannels) => {\n                    const res = [];\n                    wgs = webChannels;\n                    wgs.forEach((wg) => {\n                        expect(wg.state).toBe(WebGroupState.JOINED);\n                        wg.onMemberLeaveCalledTimes = 0;\n                        wg.onMemberLeave = (id) => {\n                            wg.onMemberLeaveCalledTimes++;\n                            expect(wg.members.includes(id)).toBeFalsy();\n                        };\n                        wg.onStateChangeCalledTimes = 0;\n                        res.push(new Promise((resolve) => {\n                            wg.onStateChange = (state) => {\n                                wg.onStateChangeCalledTimes++;\n                                if (state === WebGroupState.LEFT) {\n                                    resolve();\n                                }\n                            };\n                        }));\n                    });\n                    for (const wg of wgs) {\n                        wg.leave();\n                    }\n                    return Promise.all(res);\n                })\n                    .then(() => {\n                    wgs.forEach((wg, index) => {\n                        expect(wg.state).toBe(WebGroupState.LEFT);\n                        expect(wg.members.length).toBe(1);\n                        expect(wg.onMemberLeaveCalledTimes).toBe(numberOfPeers - 1);\n                        expect(wg.onStateChangeCalledTimes).toBe(1);\n                    });\n                })\n                    .then(done)\n                    .catch(done.fail);\n            });\n        });\n    });\n});\n",
    "static": true,
    "longname": "/home/philippe/workspace/netflux/docs/jsFromTs/test/functional/manyMembers.test.js",
    "access": null,
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 77,
    "kind": "test",
    "name": "describe11",
    "testId": 11,
    "memberof": "test/functional/manyMembers.test.js",
    "testDepth": 0,
    "static": true,
    "longname": "test/functional/manyMembers.test.js~describe11",
    "access": null,
    "description": "Many members",
    "lineNumber": 23,
    "testTargets": [
      "WebGroup"
    ]
  },
  {
    "__docId__": 78,
    "kind": "test",
    "name": "describe12",
    "testId": 12,
    "memberof": "test/functional/manyMembers.test.js~describe11",
    "testDepth": 1,
    "static": true,
    "longname": "test/functional/manyMembers.test.js~describe11.describe12",
    "access": null,
    "description": "should join",
    "lineNumber": 25,
    "testTargets": [
      "WebGroup#join"
    ]
  },
  {
    "__docId__": 79,
    "kind": "test",
    "name": "it13",
    "testId": 13,
    "memberof": "test/functional/manyMembers.test.js~describe11.describe12",
    "testDepth": 2,
    "static": true,
    "longname": "test/functional/manyMembers.test.js~describe11.describe12.it13",
    "access": null,
    "lineNumber": 29
  },
  {
    "__docId__": 80,
    "kind": "test",
    "name": "describe14",
    "testId": 14,
    "memberof": "test/functional/manyMembers.test.js~describe11",
    "testDepth": 1,
    "static": true,
    "longname": "test/functional/manyMembers.test.js~describe11.describe14",
    "access": null,
    "description": "Should ping",
    "lineNumber": 91,
    "testTargets": [
      "WebGroup#ping"
    ]
  },
  {
    "__docId__": 81,
    "kind": "test",
    "name": "it15",
    "testId": 15,
    "memberof": "test/functional/manyMembers.test.js~describe11.describe14",
    "testDepth": 2,
    "static": true,
    "longname": "test/functional/manyMembers.test.js~describe11.describe14.it15",
    "access": null,
    "lineNumber": 95
  },
  {
    "__docId__": 82,
    "kind": "test",
    "name": "describe16",
    "testId": 16,
    "memberof": "test/functional/manyMembers.test.js~describe11",
    "testDepth": 1,
    "static": true,
    "longname": "test/functional/manyMembers.test.js~describe11.describe16",
    "access": null,
    "description": "Should send/receive",
    "lineNumber": 105
  },
  {
    "__docId__": 83,
    "kind": "test",
    "name": "describe17",
    "testId": 17,
    "memberof": "test/functional/manyMembers.test.js~describe11.describe16",
    "testDepth": 2,
    "static": true,
    "longname": "test/functional/manyMembers.test.js~describe11.describe16.describe17",
    "access": null,
    "lineNumber": 110,
    "testTargets": [
      "WebGroup#sendTo"
    ]
  },
  {
    "__docId__": 84,
    "kind": "test",
    "name": "it18",
    "testId": 18,
    "memberof": "test/functional/manyMembers.test.js~describe11.describe16.describe17",
    "testDepth": 3,
    "static": true,
    "longname": "test/functional/manyMembers.test.js~describe11.describe16.describe17.it18",
    "access": null,
    "lineNumber": 111
  },
  {
    "__docId__": 85,
    "kind": "test",
    "name": "it19",
    "testId": 19,
    "memberof": "test/functional/manyMembers.test.js~describe11.describe16.describe17",
    "testDepth": 3,
    "static": true,
    "longname": "test/functional/manyMembers.test.js~describe11.describe16.describe17.it19",
    "access": null,
    "lineNumber": 119,
    "testTargets": [
      "WebGroup#send"
    ]
  },
  {
    "__docId__": 86,
    "kind": "test",
    "name": "describe20",
    "testId": 20,
    "memberof": "test/functional/manyMembers.test.js~describe11",
    "testDepth": 1,
    "static": true,
    "longname": "test/functional/manyMembers.test.js~describe11.describe20",
    "access": null,
    "lineNumber": 129
  },
  {
    "__docId__": 87,
    "kind": "test",
    "name": "describe21",
    "testId": 21,
    "memberof": "test/functional/manyMembers.test.js~describe11",
    "testDepth": 1,
    "static": true,
    "longname": "test/functional/manyMembers.test.js~describe11.describe21",
    "access": null,
    "description": "Should leave",
    "lineNumber": 148,
    "testTargets": [
      "WebGroup#leave"
    ]
  },
  {
    "__docId__": 88,
    "kind": "test",
    "name": "it22",
    "testId": 22,
    "memberof": "test/functional/manyMembers.test.js~describe11.describe21",
    "testDepth": 2,
    "static": true,
    "longname": "test/functional/manyMembers.test.js~describe11.describe21.it22",
    "access": null,
    "lineNumber": 152
  }
]