<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <base data-ice="baseUrl" href="./">
  <title data-ice="title">Manual | Netflux</title>
  <link type="text/css" rel="stylesheet" href="css/style.css">
  <link type="text/css" rel="stylesheet" href="css/prettify-tomorrow.css">
  <script src="script/prettify/prettify.js"></script>
  <script src="script/manual.js"></script>
<link rel="stylesheet" href="./inject/css/0-style.css"><meta name="description" content="Abstract peer to peer client transport API. Implementations based on WebRTC and webSocket to be done."><meta property="twitter:card" content="summary"><meta property="twitter:title" content="Netflux"><meta property="twitter:description" content="Abstract peer to peer client transport API. Implementations based on WebRTC and webSocket to be done."></head>
<body class="layout-container manual-root manual-index" data-ice="rootContainer">

<header>
  <a href="./" style="display: flex; align-items: center;"><img src="./image/brand_logo.png" style="width:34px;"></a>
  
  <a href="identifiers.html">Reference</a>
  <a href="source.html">Source</a>
  <a href="test.html" data-ice="testLink">Test</a>
  <div class="search-box">
  <span>
    <img src="./image/search.png">
    <span class="search-input-edge"></span><input class="search-input"><span class="search-input-edge"></span>
  </span>
    <ul class="search-result"></ul>
  </div>
<a style="position:relative; top:3px;" href="https://github.com/coast-team/netflux"><img width="20px" src="./image/github.png"></a></header>

<nav class="navigation" data-ice="nav"><div class="manual-toc-root">
  
<div data-ice="manual">
    <ul class="manual-toc">
      
    <li data-ice="manualNav" class="indent-h1" data-link="manual/installation.html"><a href="manual/installation.html" data-ice="link">Installation</a></li>
<li data-ice="manualNav" class="indent-h2" data-link="manual/installation.html"><a href="manual/installation.html#npm" data-ice="link">NPM</a></li>
<li data-ice="manualNav" class="indent-h2" data-link="manual/installation.html"><a href="manual/installation.html#what-you-need" data-ice="link">What you need</a></li>
<li data-ice="manualNav" class="indent-h3" data-link="manual/installation.html"><a href="manual/installation.html#signaling-server" data-ice="link">Signaling server</a></li>
<li data-ice="manualNav" class="indent-h3" data-link="manual/installation.html"><a href="manual/installation.html#stun-server" data-ice="link">STUN server</a></li>
<li data-ice="manualNav" class="indent-h3" data-link="manual/installation.html"><a href="manual/installation.html#turn-server" data-ice="link">TURN server</a></li>
<li data-ice="manualNav" class="indent-h2" data-link="manual/installation.html"><a href="manual/installation.html#how-to-deploy-stun-turn-servers" data-ice="link">How to deploy STUN/TURN servers</a></li>
</ul>
  </div>
<div data-ice="manual">
    <ul class="manual-toc">
      
    <li data-ice="manualNav" class="indent-h1" data-link="manual/usage.html"><a href="manual/usage.html" data-ice="link">Usage</a></li>
<li data-ice="manualNav" class="indent-h2" data-link="manual/usage.html"><a href="manual/usage.html#commonjs" data-ice="link">CommonJS</a></li>
<li data-ice="manualNav" class="indent-h2" data-link="manual/usage.html"><a href="manual/usage.html#es-module" data-ice="link">ES module</a></li>
<li data-ice="manualNav" class="indent-h2" data-link="manual/usage.html"><a href="manual/usage.html#umd" data-ice="link">UMD</a></li>
<li data-ice="manualNav" class="indent-h2" data-link="manual/usage.html"><a href="manual/usage.html#configuration" data-ice="link">Configuration</a></li>
</ul>
  </div>
<div data-ice="manual">
    <ul class="manual-toc">
      
    <li data-ice="manualNav" class="indent-h1" data-link="manual/bestpractices.html"><a href="manual/bestpractices.html" data-ice="link">Best practices</a></li>
<li data-ice="manualNav" class="indent-h2" data-link="manual/bestpractices.html"><a href="manual/bestpractices.html#leave-webgroup-before-browser-tab-close" data-ice="link">Leave WebGroup before Browser/Tab close</a></li>
<li data-ice="manualNav" class="indent-h2" data-link="manual/bestpractices.html"><a href="manual/bestpractices.html#listen-on-online-offline-events" data-ice="link">Listen on Online/Offline events</a></li>
<li data-ice="manualNav" class="indent-h2" data-link="manual/bestpractices.html"><a href="manual/bestpractices.html#page-visibility-api-might-be-useful-in-some-scenarios" data-ice="link">Page Visibility API might be useful in some scenarios</a></li>
</ul>
  </div>
<div data-ice="manual">
    <ul class="manual-toc">
      
    <li data-ice="manualNav" class="indent-h1" data-link="manual/faq.html"><a href="manual/faq.html" data-ice="link">FAQ</a></li>
<li data-ice="manualNav" class="indent-h4" data-link="manual/faq.html"><a href="manual/faq.html#-strong-how--code-rtcdatachannel--code--and--code-websocket--code--are-used---strong-" data-ice="link">How RTCDataChannel and WebSocket are used?</a></li>
</ul>
  </div>
</div>
</nav>

<div class="content" data-ice="content"><div class="github-markdown">
  <div class="manual-user-index" data-ice="manualUserIndex"><p><img src="manual/asset/logo_cropped.png" alt="Netflux logo" title="Netflux logo"></p>
<p>Universal Javascript <strong>peer to peer</strong> transport API for client and server.</p>
<p>Full mesh peer to peer network based on <strong>RTCDataChannel</strong> and <strong>WebSocket</strong>.</p>
<p>Send/receive <strong>String</strong> and <strong>Uint8Array</strong> data types.</p>
<p></p><p>
  <a href="https://www.npmjs.com/package/netflux">
    <img src="https://img.shields.io/npm/v/netflux.svg?style=flat-square">
  </a>&#xA0;
  <a href="https://travis-ci.org/coast-team/netflux">
    <img src="https://travis-ci.org/coast-team/netflux.svg?branch=master">
  </a>

  <br>

  <a href="https://www.bithound.io/github/coast-team/netflux">
    <img src="https://www.bithound.io/github/coast-team/netflux/badges/score.svg">
  </a>&#xA0;
  <a href="https://codeclimate.com/github/coast-team/netflux">
    <img src="https://codeclimate.com/github/coast-team/netflux/badges/gpa.svg">
  </a>&#xA0;
  <a href="https://coast-team.github.io/netflux">
    <img src="https://coast-team.github.io/netflux/badge.svg">
  </a>&#xA0;
  <a href="https://codeclimate.com/github/coast-team/netflux/coverage"><img src="https://codeclimate.com/github/coast-team/netflux/badges/coverage.svg"></a>

  <br>

  <a href="http://commitizen.github.io/cz-cli">
    <img src="https://img.shields.io/badge/commitizen-friendly-brightgreen.svg?style=flat-square">
  </a>&#xA0;
  <a href="https://github.com/semantic-release/semantic-release">
    <img src="https://img.shields.io/badge/%20%20%F0%9F%93%A6%F0%9F%9A%80-semantic--release-e10079.svg?style=flat-square">
  </a>&#xA0;
  <a href="https://gitter.im/coast-team/netflux?utm_source=badge&amp;utm_medium=badge&amp;utm_campaign=pr-badge&amp;utm_content=badge">
    <img src="https://img.shields.io/badge/GITTER-join%20chat-green.svg?style=flat-square">
  </a>
</p>

<p></p>
<p></p><p>
  <img src="manual/asset/example_support.png">
</p>

<p></p>
<h2 id="features">Features</h2><ul>
<li>Universal API (works in Chrome/Firefox and NodeJS).</li>
<li>TypeScript declaration files are included.</li>
<li>Create peer to peer full mesh network.</li>
<li>Send/receive <a href="https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/String">String</a>, [Uint8Array][Uint8Array] data types.</li>
<li>Automatic rejoin when the connection with Signaling has lost.</li>
<li>Automatic selection between <a href="https://developer.mozilla.org/en/docs/Web/API/WebSocket">WebSocket</a> &amp; <a href="https://developer.mozilla.org/en/docs/Web/API/RTCDataChannel">RTCDataChannel</a>.</li>
<li>Full control over WebRTC servers: Signaling, STUN and TURN.<ul>
<li>Deploy your own Signaling server (<a href="https://github.com/coast-team/sigver">Sigver</a>) or use one provided by default.</li>
<li>Configure STUN and TURN servers.</li>
</ul>
</li>
<li>Small Signaling server payload: server is necessary to establish the first connection with
one of the group member, then this member acts as a Signaling server to establish connections with the rest of the group members.</li>
<li>4 builds (ES5 code):<ul>
<li><code>dist/netflux.cjs.js</code> - CommonJS format for NodeJS (see <em>package.json#main</em>)</li>
<li><code>dist/esm/index.node.js</code> - ES module format for NodeJS (see <em>package.json#module</em>).</li>
<li><code>dist/esm/index.browser.js</code> - ES module format for browsers (see <em>package.json#browser</em>).</li>
<li><code>dist/netflux.umd.js</code> - UMD format for browsers.</li>
</ul>
</li>
</ul>
<h2 id="demo">Demo</h2><p>Netflux is used by our team for Multi User Text Editor (<a href="https://github.com/coast-team/mute">MUTE repo</a>) development. The demo version is available on: <a href="https://coedit.re">https://coedit.re</a></p>
</div>

  

  <div class="manual-cards">
    
  <div class="manual-card-wrap" data-ice="cards">
      <div class="manual-card">
        <div data-ice="card"><h1>Installation</h1><h2>NPM</h2><pre><code class="lang-shell"><code class="source-code prettyprint">npm install -S netflux</code>
</code></pre><p>Netflux has an optional peer dependency: <code>wrtc</code>. This package provides WebRTC API in NodeJS. It is optional because Netflux can use <code>WebSocket</code> instead. For some use cases maybe you still want to connect your server to the peer to peer network via <code>RTCDataChannel</code>, then you have to successfully install this dependency, checkout <a href="https://github.com/js-platform/node-webrtc">wrtc repository</a> then.</p><h2>What you need</h2><p>Signaling server is only mandatory server for Netflux, but for a fully functional peer to peer network (to support all use cases) we also need STUN and TURN servers.</p><p>Netflux comes with Signaling and STUN servers by default for easier quickstart. For TURN server two solutions are possible: either deploy your own or rent one at <a href="https://xirsys.com/">Xirsys</a> for example or any other similar services.</p><h3>Signaling server</h3><p><strong>Default</strong>: <code>wss://signaling.netflux.coedit.re</code></p><p>We developed a Signaling server: <a href="https://github.com/coast-team/sigver">Sigver</a>. It is the only signaling server (signaling mechanism) which is supported by Netflux for now.</p><p><strong>TIP</strong>: we recommend to deploy your own instance of Sigver for production.</p><h3>STUN server</h3><p><strong>Default</strong>: <code>stun:stun3.l.google.com:19302</code></p><p>There many other free STUN servers available in the Web.</p><h3>TURN server</h3><p>No free TURN server available in the Web. Checkout <a href="https://xirsys.com/">Xirsys</a> to rent one or deploy your own.</p><h2>How to deploy STUN/TURN servers</h2><p>This guide present a basic configuration for <a href="https://github.com/coturn/coturn">coturn</a>.
It allow us to deploy our own STUN/TURN server in order to connect users behind a NAT or Firewall.</p><p>For more informations or options, see coturn <a href="https://github.com/coturn/coturn/wiki/README">documentation</a>.</p><p>On most Linux Distribution, the package is in the repo:
<code>apt-get install coturn</code></p><p>You must have SQLite installed:
<code>sudo apt-get install sqlite3 libsqlite3-dev</code></p><p>Config file can be found at:
<code>/etc/turnserver.conf</code></p><p>Simple config file should look like this:</p><pre><code class="lang-bash"><code class="source-code prettyprint"># you can listen ports 3478 and 5349 instead of 80/443
listening-port=80
tls-listening-port=443

listening-ip=your-ip-address

relay-ip=your-ip-address
external-ip=your-ip-address

realm=yourdomain.com
server-name=yourdomain.com

# webRTC authentication method
lt-cred-mech

# Database location
userdb=/var/lib/turn/turndb

# Add ssl certificate for your server
cert=/etc/ssl/certificate.pem
pkey=/etc/ssl/private.key

no-stdout-log</code>
</code></pre><p>If you don&apos;t have any SSL certificate, you may use <a href="https://letsencrypt.org/">Let&apos;s Encrypt</a>.</p><p>Create a user in order to access your Turn server:
<code>turnadmin -a -u userName -p password -r yourdomain.com</code></p><p>Launch your server:
<code>turnserver</code>
or in daemon:
<code>turnserver -o</code></p><p>Verify that your server is up and running with <a href="https://webrtc.github.io/samples/src/content/peerconnection/trickle-ice/">Trickle ICE</a>.</p></div>
        <a data-ice="link" href="manual/installation.html"></a>
      </div>
    </div>
<div class="manual-card-wrap" data-ice="cards">
      <div class="manual-card">
        <div data-ice="card"><h1>Usage</h1><p>There are 4 builds (all ES5 code):</p><ul>
<li><code>dist/netflux.cjs.js</code> CommonJS format for NodeJS.</li>
<li><code>dist/esm/netflux.node.js</code> ECMAScript 6 module format for NodeJS.</li>
<li><code>dist/esm/netflux.browser.js</code> ECMAScript 6 module format for browsers.</li>
<li><code>dist/netflux.umd.js</code> UMD format for browsers.</li>
</ul><p>The <code>package.json</code> contains the following fields:</p><pre><code class="lang-json"><code class="source-code prettyprint">...
&quot;main&quot;: &quot;dist/netflux.cjs.js&quot;,
&quot;module&quot;: &quot;dist/esm/index.node.js&quot;,
&quot;browser&quot;: &quot;dist/esm/index.browser.js&quot;,
...</code>
</code></pre><p>All builds are either for NodeJS or for Browser environment.</p><p><strong>For browser environment</strong> exported members are:</p><ul>
<li><code>WebGroup</code></li>
<li><code>WebGroupState</code> enum</li>
<li><code>SignalingState</code> enum</li>
<li><code>Topology</code> enum</li>
<li><code>DataType</code> type</li>
<li><code>WebGroupOption</code> type</li>
</ul><p><strong>For NodeJS environment</strong> exported members are the same as for browser plus:</p><ul>
<li><code>WebGroupBotServer</code></li>
<li><code>WebGroupBotServerOptions</code> type.</li>
</ul><h2>CommonJS</h2><p><code>dist/netflux.cjs.js</code> - CommonJS format, built for NodeJS.</p><pre><code class="lang-Javascript"><code class="source-code prettyprint">// NodeJS
const netflux = require(&apos;netflux&apos;)
var wg = new netflux.WebGroup()</code>
</code></pre><h2>ES module</h2><p><code>esm/index.node.js</code> and <code>esm/index.browser.js</code> are suitable for Webpack, Browserify or any alike, which also undersands <code>package.json#module</code> and <code>package.json#module</code> properties respectively and can parse ES modules.</p><p><code>esm/index.node.js</code> is build for NodeJS: contains all exported API members and all necessary polyfills for NodeJS environment.</p><p><code>esm/index.browser.js</code>  si build for browsers.</p><pre><code class="lang-javascript"><code class="source-code prettyprint">export {WebGroup, WebGroupState, WebGroupBotServer, WebGroupBotServerOptions} from &apos;netflux&apos;
const wg = new WebGroup()</code>
</code></pre><h2>UMD</h2><p><code>dist/netflux.umd.js</code> - Universal Module Definition format is compatible with AMD, CommonJS and &quot;global&quot; modules. Built for browser and suitable for Webpack, Browserify and any other who
also understands <code>package.json#browser</code> property.</p><pre><code class="lang-html"><code class="source-code prettyprint">&lt;!-- Browser global usage example --&gt;
&lt;script src=&quot;netflux.es5.umd.js&quot;&gt;
  window.netflux !== undefined // true
  var wg = new window.netflux.WebGroup()
&lt;/script&gt;</code>
</code></pre><h2>Configuration</h2><p>For a <code>WebGroup</code> object all options are optional.</p><pre><code class="lang-javascript"><code class="source-code prettyprint">// Example:
const wg = new WebGroup({
  signalingURL: &apos;MY_SIGNALING_URL&apos;,
  iceServers: [
    {
      urls: &apos;stun.l.google.com:19302&apos;
    },
    {
      urls: [&apos;turn:myturn.com?transport=udp&apos;, &apos;turn:myturn?transport=tcp&apos;],
      username: &apos;user&apos;,
      password: &apos;password&apos;
    }
  ]
})</code>
</code></pre><p>For <code>WebGroupBotServer</code> the server option is mandatory.</p><pre><code class="lang-javascript"><code class="source-code prettyprint">// Example:
const http = require(&apos;http&apos;)
const myServer = http.createServer()
const wg = new WebGroupBotServer({
  server: myServer,
  signalingURL: &apos;MY_SIGNALING_URL&apos;,
  webGroupOptions: {
    iceServers: [
      {
        urls: &apos;stun.l.google.com:19302&apos;
      },
      {
        urls: [&apos;turn:myturn.com?transport=udp&apos;, &apos;turn:myturn?transport=tcp&apos;],
        username: &apos;user&apos;,
        password: &apos;password&apos;
      }
    ]
  }
})</code>
</code></pre></div>
        <a data-ice="link" href="manual/usage.html"></a>
      </div>
    </div>
<div class="manual-card-wrap" data-ice="cards">
      <div class="manual-card">
        <div data-ice="card"><h1>Best practices</h1><p>The behavior of Chrome and Firefox on Linux/MacOS (likely on Windows also, but not tested) concerning holding JS execution, <a href="https://developer.mozilla.org/en/docs/Online_and_offline_events">Online/Offline</a> and <a href="https://developer.mozilla.org/en/docs/Web/API/Page_Visibility_API">Page Visibility</a> APIs maybe different when OS goes into sleep mode and resumes from it. That why the practices listed here might be useful for these scenarios and not only.</p><h2>Leave WebGroup before Browser/Tab close</h2><p>Clean leave is always preferable. Other members will be notified immediately.</p><pre><code class="lang-Javascript"><code class="source-code prettyprint">// &quot;webGroup&quot; variable has been defined earlier.
window.addEventListener(&apos;beforeunload&apos;, () =&gt; {
    webGroup.leave()
})</code>
</code></pre><h2>Listen on Online/Offline events</h2><p>Maybe useful to not rejoin a web group if the client is offline anyway. Checkout <a href="https://developer.mozilla.org/en/docs/Online_and_offline_events">Online/Offline API doc</a> for more details and to understand what <em>Online</em> actually means.</p><pre><code class="lang-Javascript"><code class="source-code prettyprint">// &quot;webGroup&quot; variable has been defined earlier.

window.addEventListener(&apos;offline&apos;, () =&gt; {
    // You are offline, then leave the web group
    webGroup.leave()
})
window.addEventListener(&apos;online&apos;, () =&gt; {
    // You are online again, try to rejoin if necessary.
    webGroup.join()
})</code>
</code></pre><p><strong>Remark</strong>: It was noticed for Chrome browser on some operating systems that when the OS resumes from a sleep mode, the <em>Offline</em>/<em>Online</em> events fired twice in a very short period of time, this may cause a problem for Netflux to rejoin, so consider to do something like:</p><pre><code class="lang-Javascript"><code class="source-code prettyprint">// &quot;webGroup&quot; variable has been defined earlier.

let timer
window.addEventListener(&apos;online&apos;, () =&gt; {
  if (timer !== undefined) {
    timer = setTimeout(() =&gt; {
      webGroup.join()
      timer = undefined
    }, 500)
  }
})</code>
</code></pre><h2>Page Visibility API might be useful in some scenarios</h2><p>It was noticed that when MacOS goes into sleep mode, Chrome and Firefox do not stop JS execution, but close WebRTC connections and do not allow to create new. However the WebSocket connection is maintained. This cause problem as you are no longer connected to other peers, but the connection with Signaling server is still alive. For this reason it might be useful to do something like (checkout <a href="https://developer.mozilla.org/en/docs/Web/API/Page_Visibility_API">Page Visibility API doc</a>):</p><pre><code class="lang-Javascript"><code class="source-code prettyprint">// &quot;webGroup&quot; variable has been defined earlier.

webGroup.onMemberLeave = () =&gt; {
  if (webGroup.members.length === 0 &amp;&amp; window.document.visibilityState === &apos;hidden&apos;) {
    webGroup.leave()
  }
}

window.addEventListener(&apos;visibilitychange&apos;, () =&gt; {
  if (window.navigator.onLine &amp;&amp;
      window.document.visibilityState === &apos;visible&apos; &amp;&amp;
      webGroup.state === WebGroupState.LEFT
  ) {
    webGroup.join()
  }
})</code>
</code></pre></div>
        <a data-ice="link" href="manual/bestpractices.html"></a>
      </div>
    </div>
<div class="manual-card-wrap" data-ice="cards">
      <div class="manual-card">
        <div data-ice="card"><h1>FAQ</h1><h4><strong>How <code>RTCDataChannel</code> and <code>WebSocket</code> are used?</strong></h4><p>Netflux can create a peer to peer network with the following connection types:</p><ul>
<li><code>RTCDataChannel</code> (WebRTC)</li>
<li><code>WebSocket</code></li>
</ul><p><code>RTCDataChannel</code> connection could be established between:</p><ul>
<li>Browser &amp; Browser</li>
<li>Browser &amp; Server (If server supports)</li>
<li>Server &amp; Server (If both servers support)</li>
</ul><p>On the other hand, a <code>WebSocket</code> could be created only between:</p><ul>
<li>Browser &amp; Server</li>
<li>Server &amp; Server</li>
</ul></div>
        <a data-ice="link" href="manual/faq.html"></a>
      </div>
    </div>
</div>
</div>
</div>

<footer class="footer">
  Generated by <a href="https://esdoc.org">ESDoc<span data-ice="esdocVersion">(1.0.4)</span><img src="./image/esdoc-logo-mini-black.png"></a>
</footer>

<script src="script/search_index.js"></script>
<script src="script/search.js"></script>
<script src="script/pretty-print.js"></script>
<script src="script/inherited-summary.js"></script>
<script src="script/test-summary.js"></script>
<script src="script/inner-link.js"></script>
<script src="script/patch-for-local.js"></script>
</body>
</html>
